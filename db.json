{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yelee/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/bg-2.jpg","path":"background/bg-2.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/bg-3.jpg","path":"background/bg-3.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/bg-4.jpg","path":"background/bg-4.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/AcFun.png","path":"img/AcFun.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/CSDN.png","path":"img/CSDN.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/Coding.png","path":"img/Coding.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/LOFTER.png","path":"img/LOFTER.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/Plunker.png","path":"img/Plunker.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/Quora.png","path":"img/Quora.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/SegmentFault.png","path":"img/SegmentFault.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/TiddlyWiki.png","path":"img/TiddlyWiki.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/V2EX.png","path":"img/V2EX.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/bilibili.png","path":"img/bilibili.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/niconico.png","path":"img/niconico.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/博客园.png","path":"img/博客园.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/新浪微博.png","path":"img/新浪微博.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/知乎.png","path":"img/知乎.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/简书.png","path":"img/简书.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/网易云音乐.png","path":"img/网易云音乐.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/虾米音乐.png","path":"img/虾米音乐.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/豆瓣.png","path":"img/豆瓣.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","path":"js/GithubRepoWidget.js","modified":0,"renderable":1},{"_id":"themes/yelee/source/js/instagram.js","path":"js/instagram.js","modified":0,"renderable":1},{"_id":"themes/yelee/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/yelee/source/js/mobile.js","path":"js/mobile.js","modified":0,"renderable":1},{"_id":"themes/yelee/source/js/pc.js","path":"js/pc.js","modified":0,"renderable":1},{"_id":"themes/yelee/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/yelee/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/bg-1.jpg","path":"background/bg-1.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/bg-5.jpg","path":"background/bg-5.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/bg-6.jpg","path":"background/bg-6.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-1.jpg","path":"background/backup/bg-1.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-2.jpg","path":"background/backup/bg-2.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-3.jpg","path":"background/backup/bg-3.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-4.jpg","path":"background/backup/bg-4.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/yelee/.gitignore","hash":"79b4a9ac435bc5833a0bc461ebacb10908b34ed3","modified":1627442658164},{"_id":"themes/yelee/_config.yml","hash":"09621b27494ad97080211e4ad32f980a2a7f72d4","modified":1627527449362},{"_id":"themes/yelee/README.md","hash":"12bc9cdb68f51df81bcc36a5263e0a6c5860f646","modified":1627442658165},{"_id":"themes/yelee/package.json","hash":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1627442658211},{"_id":"source/_posts/20171212.md","hash":"fdef8a2be282970aa45cbd3c7e1db5a4fae53718","modified":1627527841384},{"_id":"source/_posts/20170918.md","hash":"4b0cefcd7968c17591768bd420e1eee2b884c315","modified":1627527449326},{"_id":"source/_posts/20180617.md","hash":"1d7271df29f1a2839159ff4713a9d8ed43f9a9ab","modified":1627538282363},{"_id":"source/_posts/20180618.md","hash":"f68f2d4a43a4dcc82d82fbbdc956b3ee1c2c08ff","modified":1627527449331},{"_id":"source/_posts/20180619.md","hash":"189e623ac025e90cbc4273d25cac462e938bd937","modified":1627527449332},{"_id":"source/_posts/20180630.md","hash":"7146caa140a279938ec5098ba0d29b32d9f7cc47","modified":1627540214263},{"_id":"source/_posts/20180720.md","hash":"306a1a6553492376780e23c8f946c650cfd110c9","modified":1627527449335},{"_id":"source/_posts/20180725.md","hash":"7b8389b1fb13700612d106a7fcdc5e7d9d53a6aa","modified":1627528163619},{"_id":"source/_posts/20180727.md","hash":"4c2ba35ad74835d5e21d8bef5d387ca6f5058132","modified":1627527449338},{"_id":"source/_posts/20180815.md","hash":"a7dd3b9448d7aa4e3ccc96495af201288fe19071","modified":1627527449341},{"_id":"source/_posts/20180802.md","hash":"6c9279ef1f255d9c8867da024421b8a7a5b8d144","modified":1627527449339},{"_id":"source/_posts/20181010.md","hash":"035c09676e99b4174192366900390d8f825cc0a9","modified":1627527449344},{"_id":"source/_posts/20180916.md","hash":"ceb0067c4339536e575090d4fd1203a2a406f1d0","modified":1627543314716},{"_id":"source/_posts/20181023.md","hash":"27188ac259461ce89c1c72986dfdd7f73954c199","modified":1627527449345},{"_id":"source/_posts/20181112.md","hash":"f095ca4b8533861072d6cda5a41230775217f938","modified":1627527449349},{"_id":"source/_posts/20181111.md","hash":"d94705a08c735932e6773aa4bde2688142d61022","modified":1627545871079},{"_id":"source/_posts/20181113.md","hash":"640ac7c78ec90e30e1da676257b18f63e801f138","modified":1627542306374},{"_id":"source/_posts/20181114.md","hash":"b6e23c62be42debe704dea3a918b60c499549638","modified":1627527449353},{"_id":"source/_posts/20181115.md","hash":"acd2e4ac72a5e8edd2ee541b3473484ebe6e4dc2","modified":1627527449354},{"_id":"source/_posts/20190112.md","hash":"a918738c522721023e048d8b0ac218cf20176918","modified":1627527449357},{"_id":"source/_posts/20190107.md","hash":"ae6c74eabb22bf2fc829e994793c126a81135fa6","modified":1627527449356},{"_id":"source/categories/index.md","hash":"29c0847328d0a937c6eb5cc67d6d76c57692c075","modified":1627442657659},{"_id":"source/tags/index.md","hash":"c82a9f2ddf4dc397e406bdd227948780d9c32953","modified":1627442657660},{"_id":"themes/yelee/languages/default.yml","hash":"3bdad891c90029447b4fbaedbbb11b8a59d06418","modified":1627442658168},{"_id":"themes/yelee/languages/en.yml","hash":"ff991c2c80d9ab69c984acb1c40480c8b98be2bc","modified":1627442658169},{"_id":"themes/yelee/languages/zh-Hans.yml","hash":"4fa4068a65089810e7dd95692f9157eb80c2e8de","modified":1627442658170},{"_id":"themes/yelee/languages/zh-Hant-HK.yml","hash":"bbc73dcd9170fe9efaab6fbbe1571886e0b8aa89","modified":1627442658171},{"_id":"themes/yelee/languages/zh-Hant-TW.yml","hash":"88b4678bba940bc270c7aea2debbf869ecf6cc18","modified":1627442658171},{"_id":"themes/yelee/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1627474087032},{"_id":"themes/yelee/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1627474087033},{"_id":"themes/yelee/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1627474087033},{"_id":"themes/yelee/layout/layout.ejs","hash":"3a4350f23a1286345f76c949466c97a7200dae8e","modified":1627442658208},{"_id":"themes/yelee/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1627474087034},{"_id":"themes/yelee/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1627474087034},{"_id":"themes/yelee/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1627474087034},{"_id":"themes/yelee/source/apple-touch-icon.png","hash":"c0fda117fa166d63b9eb690cc5e4fb2caaf493b3","modified":1627474087035},{"_id":"themes/yelee/layout/_partial/after-footer.ejs","hash":"748391b89b661fa1ed7da0b15ed6870981ec4dc3","modified":1627442658173},{"_id":"themes/yelee/layout/_partial/archive-post.ejs","hash":"0ecc2ad07b4abad80f564ac1858c50bcbdff34f8","modified":1627442658174},{"_id":"themes/yelee/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1627442658175},{"_id":"themes/yelee/layout/_partial/article.ejs","hash":"afd85b362d732fa9b439af7dc44b657d0d1aae3d","modified":1627442658176},{"_id":"themes/yelee/layout/_partial/background.ejs","hash":"aeef39abef66ee0bd6c9efe856eaeb1b81416d41","modified":1627442658177},{"_id":"themes/yelee/layout/_partial/footer.ejs","hash":"82653e3bbdc605b51e1b0a36e30f3ac1180c838e","modified":1627442658184},{"_id":"themes/yelee/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1627442658185},{"_id":"themes/yelee/layout/_partial/head.ejs","hash":"55e90c3d5de6d7ffcfe26c4dc22189a7a27b6651","modified":1627442658186},{"_id":"themes/yelee/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1627442658187},{"_id":"themes/yelee/layout/_partial/ie-updater.ejs","hash":"8d1e1f3953efbcf5ec84a451439a62a1c95b55d7","modified":1627442658187},{"_id":"themes/yelee/layout/_partial/left-col.ejs","hash":"90fd7c763faf8d64d58612f592cbacbefdaea161","modified":1627442658188},{"_id":"themes/yelee/layout/_partial/mathjax.ejs","hash":"ce868f8b2b5b377cadc270e3a5bb5826f8bf0dee","modified":1627442658190},{"_id":"themes/yelee/layout/_partial/mobile-nav.ejs","hash":"306be982577b0ef968f855d0dfeaab6b180b8a50","modified":1627442658191},{"_id":"themes/yelee/layout/_partial/open-in-new-tab.ejs","hash":"a59d4c768009dd621e741a29cf6446ebc2668fe9","modified":1627442658191},{"_id":"themes/yelee/layout/_partial/page.ejs","hash":"cfce60062cdb60893baeda7fa0266ae4086c2bc8","modified":1627442658192},{"_id":"themes/yelee/layout/_partial/post-nav-button.ejs","hash":"0a98bffdd14f6677721841c0ac4487a86c77266c","modified":1627442658193},{"_id":"themes/yelee/layout/_partial/scrolling-button.ejs","hash":"c5e1c3a8e1e6b0d927ac25a7fb8720ee7ac83ad8","modified":1627442658201},{"_id":"themes/yelee/layout/_partial/tab-title-change.ejs","hash":"7c4a7177e0c77de2d7607ca29fc395abebd34db7","modified":1627442658202},{"_id":"themes/yelee/layout/_partial/tag-cloud-page.ejs","hash":"c7b25ef136e129c948ac37d6ff19e8815ab9fee6","modified":1627442658203},{"_id":"themes/yelee/layout/_partial/toc.ejs","hash":"7ee88b1a98eea5cbd44c0f9a11b86b46aa2d6752","modified":1627442658203},{"_id":"themes/yelee/source/background/bg-2.jpg","hash":"d1e0b92e8fa822e44d185b5e1bf94ab47bc98a0a","modified":1627474087038},{"_id":"themes/yelee/source/background/bg-3.jpg","hash":"d476909f06fe8267c676952e3582bf9e9ff73585","modified":1627474087038},{"_id":"themes/yelee/source/background/bg-4.jpg","hash":"8e80d0b7786c3bf7b9648c0190719e78001e9eeb","modified":1627474087039},{"_id":"themes/yelee/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1627442658231},{"_id":"themes/yelee/source/css/_variables.styl","hash":"f429eb9bc9f0a270ec68c4f4c63903250746a01c","modified":1627442658256},{"_id":"themes/yelee/source/css/style.styl","hash":"b285f9a75abd09c7d06fe89e70f9e1819eac27dd","modified":1627442658257},{"_id":"themes/yelee/source/img/AcFun.png","hash":"df6b0fa39ced4dc988359fc7b7cd1e5403de08a6","modified":1627474087046},{"_id":"themes/yelee/source/img/CSDN.png","hash":"59f7d89eda8a7310a0ee1607e153c0829af7eb6e","modified":1627474087046},{"_id":"themes/yelee/source/img/Coding.png","hash":"afb4bce19bebf61e3c486fd5199369d6eb191b78","modified":1627474087046},{"_id":"themes/yelee/source/img/LOFTER.png","hash":"88670eaea8612839e9d6a40a3636e4231ab56c0f","modified":1627474087046},{"_id":"themes/yelee/source/img/Plunker.png","hash":"14a0054b9b4a0e459987f34b9ab48ab22dbe5cf9","modified":1627474087046},{"_id":"themes/yelee/source/img/Quora.png","hash":"1a624ade0d07f2482b21bef1e2a5ddd0110ba352","modified":1627474087046},{"_id":"themes/yelee/source/img/SegmentFault.png","hash":"1afbc7e575e2e9ed9404be84a3f92f7ca8345a9c","modified":1627474087047},{"_id":"themes/yelee/source/img/TiddlyWiki.png","hash":"b7f68f8f9c45561a9455aee0bfb80e35cae6f8df","modified":1627474087047},{"_id":"themes/yelee/source/img/V2EX.png","hash":"d0768de8555f9be0ee8ce956198cef454d4e4d7c","modified":1627474087047},{"_id":"themes/yelee/source/img/avatar.png","hash":"e4bca3d60087cd6e775d8e2aa2bf0d35e3859592","modified":1627474087047},{"_id":"themes/yelee/source/img/bilibili.png","hash":"be37b7e9a091c8547b8ee8b9d29583af8ded61c0","modified":1627474087047},{"_id":"themes/yelee/source/img/niconico.png","hash":"fabc7ca45e9ee5698db33a25de8b1f8a7c7d6723","modified":1627474087047},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","hash":"af987032f2171867bb58b165d2180eb5dcbea637","modified":1627474087048},{"_id":"themes/yelee/source/img/博客园.png","hash":"5ff6f4c9f1fc1695217a57436d58b246d9d2f197","modified":1627474087048},{"_id":"themes/yelee/source/img/新浪微博.png","hash":"7a145ed1daee0c172cda77098f4254fc21f9eeee","modified":1627474087048},{"_id":"themes/yelee/source/img/知乎.png","hash":"ed6d3c304789e112d09f40784fa6add1f1a38bd6","modified":1627474087048},{"_id":"themes/yelee/source/img/简书.png","hash":"5c91ee83cab4abe160240e09de345b6935c8cb37","modified":1627474087048},{"_id":"themes/yelee/source/img/网易云音乐.png","hash":"4fd1275fd988584811cf710207eb077f2306f271","modified":1627474087048},{"_id":"themes/yelee/source/img/虾米音乐.png","hash":"a0039b049779b1f37c0b0b91760943b7bf25c8f1","modified":1627474087048},{"_id":"themes/yelee/source/img/豆瓣.png","hash":"f1fc97f98612bcdf4a681542e5388483b40a5300","modified":1627474087049},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","hash":"5fb1bf6cf973062771ddf275ceeca5bc69c81c77","modified":1627442658282},{"_id":"themes/yelee/source/js/instagram.js","hash":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1627442658283},{"_id":"themes/yelee/source/js/main.js","hash":"369774a7ff45a2e5117a796330a04aeb50a61fdf","modified":1627442658285},{"_id":"themes/yelee/source/js/mobile.js","hash":"8abc32d18f16db56f51caad607cffb6ca756eca9","modified":1627442658286},{"_id":"themes/yelee/source/js/pc.js","hash":"bc289c5dc610e2a34d308daeb9adea96d01f7788","modified":1627442658287},{"_id":"themes/yelee/source/js/search.js","hash":"001e324844e63f3bfb6f60d173b9c6954127be0b","modified":1627442658288},{"_id":"themes/yelee/source/js/toc.js","hash":"973c1a4e2c9de8f4f662b99623027658fe6d94c2","modified":1627442658289},{"_id":"themes/yelee/source/background/bg-1.jpg","hash":"9a5241de4c880f13a278f6980bf11d4dfb214d82","modified":1627474087037},{"_id":"themes/yelee/source/background/bg-5.jpg","hash":"e4a3631b6b0f94ebce30a6f01ecb2b6ed7cfdb0b","modified":1627474087039},{"_id":"themes/yelee/source/background/bg-6.jpg","hash":"51b427f07ffc6f2ad97651f23cc16e8f19ed02f9","modified":1627474087040},{"_id":"themes/yelee/layout/_partial/comments/click2show.ejs","hash":"ecc4d3ca997c6fd127e00fa2edf0158b925d1d3e","modified":1627442658178},{"_id":"themes/yelee/layout/_partial/comments/count-comment.ejs","hash":"ada2032e401b73b312c50b75bdbb8ee71d5a291e","modified":1627442658180},{"_id":"themes/yelee/layout/_partial/comments/disqus.ejs","hash":"df7ee469b648b12b5ee3104ef513d54cbb7418af","modified":1627442658181},{"_id":"themes/yelee/layout/_partial/comments/duoshuo.ejs","hash":"e7f12f1246a67a5b556c2d5b37dc78733f1cf15a","modified":1627442658182},{"_id":"themes/yelee/layout/_partial/comments/youyan.ejs","hash":"d150085faee4809ba50f69c55d904605699040cb","modified":1627442658183},{"_id":"themes/yelee/layout/_partial/post/category.ejs","hash":"08c8d98bc6a73d3f72a3b0b30521ff28e1b657a7","modified":1627442658194},{"_id":"themes/yelee/layout/_partial/post/date.ejs","hash":"329ed372296a86bce73ff8936af5601723fdd70a","modified":1627442658195},{"_id":"themes/yelee/layout/_partial/post/nav.ejs","hash":"6f531dbc9cc7ae42d2486d6707f826cfe7d9d8bc","modified":1627442658197},{"_id":"themes/yelee/layout/_partial/post/share.ejs","hash":"58c2db54a9867aaafe68a7f052b04701c7c3df0f","modified":1627442658198},{"_id":"themes/yelee/layout/_partial/post/tag.ejs","hash":"7d2693a1162bf26e4b1ae9b789e0b2a2637ddbd5","modified":1627442658199},{"_id":"themes/yelee/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1627442658200},{"_id":"themes/yelee/source/background/backup/bg-1.jpg","hash":"31d7bb15211000c05656899302f8ec9ee3de0e9f","modified":1627474087035},{"_id":"themes/yelee/source/background/backup/bg-2.jpg","hash":"7ae358f3ab8b41558444053400e796c41b3ba0e2","modified":1627474087036},{"_id":"themes/yelee/source/background/backup/bg-3.jpg","hash":"1a06d3a660bfb99b62d760e4e1e09de168a4c74c","modified":1627474087037},{"_id":"themes/yelee/source/background/backup/bg-4.jpg","hash":"6df1383d0f6134016d844df9abb740a6e0c0b2c5","modified":1627474087037},{"_id":"themes/yelee/source/css/_partial/archive.styl","hash":"102c23dbb6cde3cbfca3b151c742e0d77911186e","modified":1627442658232},{"_id":"themes/yelee/source/css/_partial/footer.styl","hash":"a419108f1b820c59fcc56d218bfaaa4ffc4f1d4d","modified":1627442658241},{"_id":"themes/yelee/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1627442658242},{"_id":"themes/yelee/source/css/_partial/highlight.styl","hash":"4e34bf9340ce9b15d2d59fc4ea761d1d110927cf","modified":1627442658243},{"_id":"themes/yelee/source/css/_partial/instagram.styl","hash":"a093443add2f529396d6b6bdef1675bc3acf3958","modified":1627442658244},{"_id":"themes/yelee/source/css/_partial/main.styl","hash":"405db411896f3c7de9e7dd27e58c920fb90b9834","modified":1627442658245},{"_id":"themes/yelee/source/css/_partial/mobile-slider.styl","hash":"39db458d4e9f6973afc1390b4d3fc0291fff4c40","modified":1627442658246},{"_id":"themes/yelee/source/css/_partial/mobile.styl","hash":"dfb20f2515a26d75e42fe09741e91cc889426b11","modified":1627442658247},{"_id":"themes/yelee/source/css/_partial/page.styl","hash":"ca3f871adf8fdb296e4394070605dded53d93cb2","modified":1627442658248},{"_id":"themes/yelee/source/css/_partial/scroll.styl","hash":"f32deb9192568a2ea789d77a23a08d07f4e57d59","modified":1627442658248},{"_id":"themes/yelee/source/css/_partial/search.styl","hash":"688ff535a6005be02d947be75d22cfe1f8ce72cd","modified":1627442658249},{"_id":"themes/yelee/source/css/_partial/share.styl","hash":"88c1277397b71eb1f3473a94d9542314f983cd09","modified":1627442658250},{"_id":"themes/yelee/source/css/_partial/tagcloud.styl","hash":"b38b275728bfe11809defe1077b03cb423c3c92f","modified":1627442658251},{"_id":"themes/yelee/source/css/_partial/toc.styl","hash":"8f2a057dc072285093e37f1f645e9cb53608642f","modified":1627442658252},{"_id":"themes/yelee/source/css/_partial/wheelmenu.styl","hash":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1627442658253},{"_id":"themes/yelee/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1627442658254},{"_id":"themes/yelee/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1627442658255},{"_id":"themes/yelee/source/css/_partial/article.styl","hash":"190828c822096bb3098a7d14c3340eb004057aa0","modified":1627442658233},{"_id":"themes/yelee/source/css/_partial/customise/blockquote.styl","hash":"5e6edb9ad49288743ed550a2bd8c9a3c8e208455","modified":1627442658234},{"_id":"themes/yelee/source/css/_partial/customise/code-block.styl","hash":"4db1a992a06fd92b779f0afc9bb8bb3667bdb101","modified":1627442658235},{"_id":"themes/yelee/source/css/_partial/customise/heading.styl","hash":"c29799f09ebd87767fd9cc3b1fa795db44a94670","modified":1627442658237},{"_id":"themes/yelee/source/css/_partial/customise/color-scheme.styl","hash":"b58262a9f8903e75df431291745e19ccd8ff243a","modified":1627442658236},{"_id":"themes/yelee/source/css/_partial/customise/inline-code.styl","hash":"a15292b2b3541ea022c0fb7441875192dee5ad9d","modified":1627442658238},{"_id":"themes/yelee/source/css/_partial/customise/list.styl","hash":"7db683e2837a078ad7817fb88914535588e49cfa","modified":1627442658239},{"_id":"themes/yelee/source/css/_partial/customise/social-icon.styl","hash":"bfa5c863d474266f32a570e34a0effda964f7f40","modified":1627442658240},{"_id":"source/_posts/20210728.md","hash":"bb30eee3dd1474cc50db4bf8ec519556e8a2dadc","modified":1627527449358},{"_id":"themes/yelee/.DS_Store","hash":"4efa80e908b662457909f16f0e0ea0c3389a1199","modified":1627480155873},{"_id":"source/about/index.md","hash":"ddad9b15c7bc5949daed0286f03bc837e88825fb","modified":1627527449360},{"_id":"themes/yelee/source/.DS_Store","hash":"f20e7d0687d30cd8278a2fc4e94457f56cb46aad","modified":1627480155872},{"_id":"themes/yelee/source/img/个人头像.jpg","hash":"786b9d3e4ccfb13469ba3abb0b60618153bebb0a","modified":1590048221098}],"Category":[{"name":"基础模块","_id":"ckrnl9zmx0001ny0mjbrxfm0s"},{"name":"应用模块","_id":"ckrnldpot0009ny0m2rsctnzz"},{"name":"综合模块","_id":"ckrnlf8r3000ony0md8mgqhtq"}],"Data":[],"Page":[{"title":"分类","date":"2017-12-23T12:34:27.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-12-23 20:34:27\ntype: \"categories\"\n---\n","updated":"2021-07-28T03:24:17.659Z","path":"categories/index.html","_id":"ckrnhewkj0000eg0me8327hzs","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2017-07-28T07:17:20.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-07-28 15:17:20\ntype: \"tags\"\n---\n","updated":"2021-07-28T03:24:17.660Z","path":"tags/index.html","_id":"ckrnhewko0002eg0mu2ftdr9w","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于我","date":"2017-12-23T12:34:27.000Z","type":"about","_content":"Java程序员\n\n# 工作经历\n* 2019.11 - 至今 ：上海仙豆智能机器人有限公司\n* 2018.10 - 2019.11 上海中移智行有限公司\n* 2015.12 - 2018.10 : 苏州科达科技股份有限公司\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2017-12-23 20:34:27\ntype: \"about\"\n---\nJava程序员\n\n# 工作经历\n* 2019.11 - 至今 ：上海仙豆智能机器人有限公司\n* 2018.10 - 2019.11 上海中移智行有限公司\n* 2015.12 - 2018.10 : 苏州科达科技股份有限公司\n\n","updated":"2021-07-29T02:57:29.360Z","path":"about/index.html","_id":"ckrnjpgmn0000ny0mfku5uf0x","comments":1,"layout":"page","content":"<p>Java程序员</p>\n<h1 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h1><ul>\n<li>2019.11 - 至今 ：上海仙豆智能机器人有限公司</li>\n<li>2018.10 - 2019.11 上海中移智行有限公司</li>\n<li>2015.12 - 2018.10 : 苏州科达科技股份有限公司</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Java程序员</p>\n<h1 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h1><ul>\n<li>2019.11 - 至今 ：上海仙豆智能机器人有限公司</li>\n<li>2018.10 - 2019.11 上海中移智行有限公司</li>\n<li>2015.12 - 2018.10 : 苏州科达科技股份有限公司</li>\n</ul>\n"}],"Post":[{"title":"操作系统与计算机网络","_content":"\n<!-- more -->\n\n## 计算机网络\n\n### HTTP\n\n### TCP\n三次握手建连\n![img](http://s0.lgstatic.com/i/image2/M01/8A/6E/CgotOV13hviAU5H3AAAyMppFmf8039.png)\n\n四次挥手断连\n![img](http://s0.lgstatic.com/i/image2/M01/8A/4E/CgoB5l13hviAZRJ1AABEfmQ55Jw991.png)\n\n### UDP\n\n### QUIC\n\n### RPC\n\n### MQTT\n\n### GB32960(新能源通信协议)\n[在线文档](http://c.gb688.cn/bzgk/gb/showGb?type=online&hcno=674DE45C0AD3DE2CD75B9C4CD8ED57C1)\n\n\n## 操作系统\n\n### top\n### netstat\n\n## 经验\n生产配置：4C8G\n\n\n","source":"_posts/20171212.md","raw":"---\ntitle: 操作系统与计算机网络\ncategory: 基础模块\n---\n\n<!-- more -->\n\n## 计算机网络\n\n### HTTP\n\n### TCP\n三次握手建连\n![img](http://s0.lgstatic.com/i/image2/M01/8A/6E/CgotOV13hviAU5H3AAAyMppFmf8039.png)\n\n四次挥手断连\n![img](http://s0.lgstatic.com/i/image2/M01/8A/4E/CgoB5l13hviAZRJ1AABEfmQ55Jw991.png)\n\n### UDP\n\n### QUIC\n\n### RPC\n\n### MQTT\n\n### GB32960(新能源通信协议)\n[在线文档](http://c.gb688.cn/bzgk/gb/showGb?type=online&hcno=674DE45C0AD3DE2CD75B9C4CD8ED57C1)\n\n\n## 操作系统\n\n### top\n### netstat\n\n## 经验\n生产配置：4C8G\n\n\n","slug":"20171212","published":1,"date":"2021-07-29T02:57:29.328Z","updated":"2021-07-29T03:04:01.384Z","_id":"ckrnhewkl0001eg0mqj56vt65","comments":1,"layout":"post","photos":[],"link":"","content":"<a id=\"more\"></a>\n<h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2><h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><h3 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h3><p>三次握手建连<br><img src=\"http://s0.lgstatic.com/i/image2/M01/8A/6E/CgotOV13hviAU5H3AAAyMppFmf8039.png\" alt=\"img\"></p>\n<p>四次挥手断连<br><img src=\"http://s0.lgstatic.com/i/image2/M01/8A/4E/CgoB5l13hviAZRJ1AABEfmQ55Jw991.png\" alt=\"img\"></p>\n<h3 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h3><h3 id=\"QUIC\"><a href=\"#QUIC\" class=\"headerlink\" title=\"QUIC\"></a>QUIC</h3><h3 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h3><h3 id=\"MQTT\"><a href=\"#MQTT\" class=\"headerlink\" title=\"MQTT\"></a>MQTT</h3><h3 id=\"GB32960-新能源通信协议\"><a href=\"#GB32960-新能源通信协议\" class=\"headerlink\" title=\"GB32960(新能源通信协议)\"></a>GB32960(新能源通信协议)</h3><p><a href=\"http://c.gb688.cn/bzgk/gb/showGb?type=online&amp;hcno=674DE45C0AD3DE2CD75B9C4CD8ED57C1\" target=\"_blank\" rel=\"external\">在线文档</a></p>\n<h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><h3 id=\"top\"><a href=\"#top\" class=\"headerlink\" title=\"top\"></a>top</h3><h3 id=\"netstat\"><a href=\"#netstat\" class=\"headerlink\" title=\"netstat\"></a>netstat</h3><h2 id=\"经验\"><a href=\"#经验\" class=\"headerlink\" title=\"经验\"></a>经验</h2><p>生产配置：4C8G</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2><h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><h3 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h3><p>三次握手建连<br><img src=\"http://s0.lgstatic.com/i/image2/M01/8A/6E/CgotOV13hviAU5H3AAAyMppFmf8039.png\" alt=\"img\"></p>\n<p>四次挥手断连<br><img src=\"http://s0.lgstatic.com/i/image2/M01/8A/4E/CgoB5l13hviAZRJ1AABEfmQ55Jw991.png\" alt=\"img\"></p>\n<h3 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h3><h3 id=\"QUIC\"><a href=\"#QUIC\" class=\"headerlink\" title=\"QUIC\"></a>QUIC</h3><h3 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h3><h3 id=\"MQTT\"><a href=\"#MQTT\" class=\"headerlink\" title=\"MQTT\"></a>MQTT</h3><h3 id=\"GB32960-新能源通信协议\"><a href=\"#GB32960-新能源通信协议\" class=\"headerlink\" title=\"GB32960(新能源通信协议)\"></a>GB32960(新能源通信协议)</h3><p><a href=\"http://c.gb688.cn/bzgk/gb/showGb?type=online&amp;hcno=674DE45C0AD3DE2CD75B9C4CD8ED57C1\" target=\"_blank\" rel=\"external\">在线文档</a></p>\n<h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><h3 id=\"top\"><a href=\"#top\" class=\"headerlink\" title=\"top\"></a>top</h3><h3 id=\"netstat\"><a href=\"#netstat\" class=\"headerlink\" title=\"netstat\"></a>netstat</h3><h2 id=\"经验\"><a href=\"#经验\" class=\"headerlink\" title=\"经验\"></a>经验</h2><p>生产配置：4C8G</p>"},{"title":"硬技能图谱","_content":"\n努力很容易，坚持努力很难，不忘初心，方得始终。\n<!-- more -->\n![img](http://s0.lgstatic.com/i/image2/M01/89/5A/CgoB5l12QGeAX1jpAADXc8NHFMU588.png)\n","source":"_posts/20170918.md","raw":"---\ntitle: 硬技能图谱\ncategory: 综合模块\n---\n\n努力很容易，坚持努力很难，不忘初心，方得始终。\n<!-- more -->\n![img](http://s0.lgstatic.com/i/image2/M01/89/5A/CgoB5l12QGeAX1jpAADXc8NHFMU588.png)\n","slug":"20170918","published":1,"date":"2021-07-29T02:57:29.326Z","updated":"2021-07-29T02:57:29.326Z","_id":"ckrnhewko0003eg0mrjfywis0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>努力很容易，坚持努力很难，不忘初心，方得始终。<br><a id=\"more\"></a><br><img src=\"http://s0.lgstatic.com/i/image2/M01/89/5A/CgoB5l12QGeAX1jpAADXc8NHFMU588.png\" alt=\"img\"></p>\n","site":{"data":{}},"excerpt":"<p>努力很容易，坚持努力很难，不忘初心，方得始终。<br>","more":"<br><img src=\"http://s0.lgstatic.com/i/image2/M01/89/5A/CgoB5l12QGeAX1jpAADXc8NHFMU588.png\" alt=\"img\"></p>"},{"title":"设计模式","_content":"\n设计模式分为 3 大类型共 23 种：\n* 创建型：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。\n* 结构型：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。\n* 行为型：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n<!-- more -->\n\n# 单例模式\n\n# 工厂模式\n\n# 代理模式\n\n# 责任链模式\n\n# 适配器模式\n\n# 观察者模式\n\n# 构造者模式\n","source":"_posts/20180618.md","raw":"---\ntitle: 设计模式\ncategory: 基础模块\n---\n\n设计模式分为 3 大类型共 23 种：\n* 创建型：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。\n* 结构型：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。\n* 行为型：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n<!-- more -->\n\n# 单例模式\n\n# 工厂模式\n\n# 代理模式\n\n# 责任链模式\n\n# 适配器模式\n\n# 观察者模式\n\n# 构造者模式\n","slug":"20180618","published":1,"date":"2021-07-29T02:57:29.331Z","updated":"2021-07-29T02:57:29.331Z","_id":"ckrnhewkp0004eg0m6bjjn0cm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>设计模式分为 3 大类型共 23 种：</p>\n<ul>\n<li>创建型：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>\n<li>结构型：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>\n<li>行为型：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。<a id=\"more\"></a>\n</li>\n</ul>\n<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><h1 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h1><h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><h1 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h1><h1 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h1><h1 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h1><h1 id=\"构造者模式\"><a href=\"#构造者模式\" class=\"headerlink\" title=\"构造者模式\"></a>构造者模式</h1>","site":{"data":{}},"excerpt":"<p>设计模式分为 3 大类型共 23 种：</p>\n<ul>\n<li>创建型：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>\n<li>结构型：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>\n<li>行为型：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。","more":"</li>\n</ul>\n<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><h1 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h1><h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><h1 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h1><h1 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h1><h1 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h1><h1 id=\"构造者模式\"><a href=\"#构造者模式\" class=\"headerlink\" title=\"构造者模式\"></a>构造者模式</h1>"},{"title":"Java","_content":"\n## 常用集合\n### HashMap\n实现：数组加链表，数组中的每一项是一个链表，通过计算存入对象的 HashCode，来计算对象在数组中要存入的位置，用链表来解决散列冲突，链表中的节点存储的是键值对。\n### ConcurrentHashMap\n1.7：使用 Segment 进行分段加锁，降低并发锁定；\n1.8：使用 CAS 自旋锁的乐观锁来提高性能，但是在并发度较高时性能会比较一般\n\n\n## JUC\n### 原子类\n例如：AtomicBoolean、AtomicLong、AtomicInteger、LongAdder、LongAccumulator等。\nAtomicLong：通过 unsafe 类实现，基于CAS。\nLongAdder：基于Cell，分段锁思想，空间换时间，更适合高并发场景。\nLongAccumulator：提供了比LongAdder更强大的功能，能够指定对数据的操作规则，例如可以把对数据的相加操作改成相乘操作。\n### 锁类\nReentrantLock\nReentrantReadWriteLock\nStampedLock：JDK 1.8 改进的读写锁，是使用一种 CLH 的乐观锁，能够有效防止写饥饿。所谓写饥饿就是在多线程读写时，读线程访问非常频繁，导致总是有读线程占用资源，写线程很难加上写锁。\nLockSupport\n### 异步执行类\nExecutors：用于创建线程池\nForkJoinPool：1.7提供，采用分治思想，将大任务分解成多个小任务处理，然后在合并处理结果。特点是使用工作窃取算法，可以有效平衡多任务时间长短不一的场景。\nFutureTask\nCompletableFuture：可以支持流式调用，可以方便的进行多 future 的组合使用，例如可以同时执行两个异步任务，然后对执行结果进行合并处理。还可以很方便地设置完成时间。\n### 阻塞队列类\nLinkedBlockingDeque：双端队列，也就是可以分别从队头和队尾操作入队、出队。\nArrayBlockingQueue：单端队列，只能从队尾入队，队头出队。 \n### 多线程协作类\nCountDownLatch：实现计数器功能，可以用来控制等待多个线程执行任务后进行汇总。\nCyclicBarrier：可以让一组线程等待至某个状态之后，再全部同时执行，一般在测试时使用，可以让多线程更好的并发执行。\nSemaphore：用来控制对共享资源的访问并发度。允许多个线程共享资源，适用于限制使用共享资源线程数量的场景，例如 100 个车辆要使用 20 个停车位，那么最多允许 20 个车占用停车位。\n### 集合类\nConcurrentHashMap：线程安全的HashMap。\nCopyOnWriteArrayList：通过写入数据时进行 copy 修改，然后更新引用的方式，来消除并行读写中的锁使用，比较适合读多写少，数据量比较小，但是并发非常高的场景。\n\n## 反射\n\n## 动态代理\n\n### JDK动态代理\n\n### CGLIB动态代理\nJDK 动态代理只能代理实现了接口的类或者直接代理接口；CGLIB 可以代理未实现任何接口的类，但不能代理声明为 final 类型的类和方法。\n\n## 基础数据类型\n\n## 对象引用\n\n## 异常\n\n## 注解\n\n## SPI\n\n## 版本特性\n\n","source":"_posts/20180617.md","raw":"---\ntitle: Java\ncategory: 基础模块\n---\n\n## 常用集合\n### HashMap\n实现：数组加链表，数组中的每一项是一个链表，通过计算存入对象的 HashCode，来计算对象在数组中要存入的位置，用链表来解决散列冲突，链表中的节点存储的是键值对。\n### ConcurrentHashMap\n1.7：使用 Segment 进行分段加锁，降低并发锁定；\n1.8：使用 CAS 自旋锁的乐观锁来提高性能，但是在并发度较高时性能会比较一般\n\n\n## JUC\n### 原子类\n例如：AtomicBoolean、AtomicLong、AtomicInteger、LongAdder、LongAccumulator等。\nAtomicLong：通过 unsafe 类实现，基于CAS。\nLongAdder：基于Cell，分段锁思想，空间换时间，更适合高并发场景。\nLongAccumulator：提供了比LongAdder更强大的功能，能够指定对数据的操作规则，例如可以把对数据的相加操作改成相乘操作。\n### 锁类\nReentrantLock\nReentrantReadWriteLock\nStampedLock：JDK 1.8 改进的读写锁，是使用一种 CLH 的乐观锁，能够有效防止写饥饿。所谓写饥饿就是在多线程读写时，读线程访问非常频繁，导致总是有读线程占用资源，写线程很难加上写锁。\nLockSupport\n### 异步执行类\nExecutors：用于创建线程池\nForkJoinPool：1.7提供，采用分治思想，将大任务分解成多个小任务处理，然后在合并处理结果。特点是使用工作窃取算法，可以有效平衡多任务时间长短不一的场景。\nFutureTask\nCompletableFuture：可以支持流式调用，可以方便的进行多 future 的组合使用，例如可以同时执行两个异步任务，然后对执行结果进行合并处理。还可以很方便地设置完成时间。\n### 阻塞队列类\nLinkedBlockingDeque：双端队列，也就是可以分别从队头和队尾操作入队、出队。\nArrayBlockingQueue：单端队列，只能从队尾入队，队头出队。 \n### 多线程协作类\nCountDownLatch：实现计数器功能，可以用来控制等待多个线程执行任务后进行汇总。\nCyclicBarrier：可以让一组线程等待至某个状态之后，再全部同时执行，一般在测试时使用，可以让多线程更好的并发执行。\nSemaphore：用来控制对共享资源的访问并发度。允许多个线程共享资源，适用于限制使用共享资源线程数量的场景，例如 100 个车辆要使用 20 个停车位，那么最多允许 20 个车占用停车位。\n### 集合类\nConcurrentHashMap：线程安全的HashMap。\nCopyOnWriteArrayList：通过写入数据时进行 copy 修改，然后更新引用的方式，来消除并行读写中的锁使用，比较适合读多写少，数据量比较小，但是并发非常高的场景。\n\n## 反射\n\n## 动态代理\n\n### JDK动态代理\n\n### CGLIB动态代理\nJDK 动态代理只能代理实现了接口的类或者直接代理接口；CGLIB 可以代理未实现任何接口的类，但不能代理声明为 final 类型的类和方法。\n\n## 基础数据类型\n\n## 对象引用\n\n## 异常\n\n## 注解\n\n## SPI\n\n## 版本特性\n\n","slug":"20180617","published":1,"date":"2021-07-29T02:57:29.329Z","updated":"2021-07-29T05:58:02.363Z","_id":"ckrnhewkq0005eg0mfw3pflxo","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"常用集合\"><a href=\"#常用集合\" class=\"headerlink\" title=\"常用集合\"></a>常用集合</h2><h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><p>实现：数组加链表，数组中的每一项是一个链表，通过计算存入对象的 HashCode，来计算对象在数组中要存入的位置，用链表来解决散列冲突，链表中的节点存储的是键值对。</p>\n<h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><p>1.7：使用 Segment 进行分段加锁，降低并发锁定；<br>1.8：使用 CAS 自旋锁的乐观锁来提高性能，但是在并发度较高时性能会比较一般</p>\n<h2 id=\"JUC\"><a href=\"#JUC\" class=\"headerlink\" title=\"JUC\"></a>JUC</h2><h3 id=\"原子类\"><a href=\"#原子类\" class=\"headerlink\" title=\"原子类\"></a>原子类</h3><p>例如：AtomicBoolean、AtomicLong、AtomicInteger、LongAdder、LongAccumulator等。<br>AtomicLong：通过 unsafe 类实现，基于CAS。<br>LongAdder：基于Cell，分段锁思想，空间换时间，更适合高并发场景。<br>LongAccumulator：提供了比LongAdder更强大的功能，能够指定对数据的操作规则，例如可以把对数据的相加操作改成相乘操作。</p>\n<h3 id=\"锁类\"><a href=\"#锁类\" class=\"headerlink\" title=\"锁类\"></a>锁类</h3><p>ReentrantLock<br>ReentrantReadWriteLock<br>StampedLock：JDK 1.8 改进的读写锁，是使用一种 CLH 的乐观锁，能够有效防止写饥饿。所谓写饥饿就是在多线程读写时，读线程访问非常频繁，导致总是有读线程占用资源，写线程很难加上写锁。<br>LockSupport</p>\n<h3 id=\"异步执行类\"><a href=\"#异步执行类\" class=\"headerlink\" title=\"异步执行类\"></a>异步执行类</h3><p>Executors：用于创建线程池<br>ForkJoinPool：1.7提供，采用分治思想，将大任务分解成多个小任务处理，然后在合并处理结果。特点是使用工作窃取算法，可以有效平衡多任务时间长短不一的场景。<br>FutureTask<br>CompletableFuture：可以支持流式调用，可以方便的进行多 future 的组合使用，例如可以同时执行两个异步任务，然后对执行结果进行合并处理。还可以很方便地设置完成时间。</p>\n<h3 id=\"阻塞队列类\"><a href=\"#阻塞队列类\" class=\"headerlink\" title=\"阻塞队列类\"></a>阻塞队列类</h3><p>LinkedBlockingDeque：双端队列，也就是可以分别从队头和队尾操作入队、出队。<br>ArrayBlockingQueue：单端队列，只能从队尾入队，队头出队。 </p>\n<h3 id=\"多线程协作类\"><a href=\"#多线程协作类\" class=\"headerlink\" title=\"多线程协作类\"></a>多线程协作类</h3><p>CountDownLatch：实现计数器功能，可以用来控制等待多个线程执行任务后进行汇总。<br>CyclicBarrier：可以让一组线程等待至某个状态之后，再全部同时执行，一般在测试时使用，可以让多线程更好的并发执行。<br>Semaphore：用来控制对共享资源的访问并发度。允许多个线程共享资源，适用于限制使用共享资源线程数量的场景，例如 100 个车辆要使用 20 个停车位，那么最多允许 20 个车占用停车位。</p>\n<h3 id=\"集合类\"><a href=\"#集合类\" class=\"headerlink\" title=\"集合类\"></a>集合类</h3><p>ConcurrentHashMap：线程安全的HashMap。<br>CopyOnWriteArrayList：通过写入数据时进行 copy 修改，然后更新引用的方式，来消除并行读写中的锁使用，比较适合读多写少，数据量比较小，但是并发非常高的场景。</p>\n<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><h3 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h3><h3 id=\"CGLIB动态代理\"><a href=\"#CGLIB动态代理\" class=\"headerlink\" title=\"CGLIB动态代理\"></a>CGLIB动态代理</h3><p>JDK 动态代理只能代理实现了接口的类或者直接代理接口；CGLIB 可以代理未实现任何接口的类，但不能代理声明为 final 类型的类和方法。</p>\n<h2 id=\"基础数据类型\"><a href=\"#基础数据类型\" class=\"headerlink\" title=\"基础数据类型\"></a>基础数据类型</h2><h2 id=\"对象引用\"><a href=\"#对象引用\" class=\"headerlink\" title=\"对象引用\"></a>对象引用</h2><h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><h2 id=\"SPI\"><a href=\"#SPI\" class=\"headerlink\" title=\"SPI\"></a>SPI</h2><h2 id=\"版本特性\"><a href=\"#版本特性\" class=\"headerlink\" title=\"版本特性\"></a>版本特性</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"常用集合\"><a href=\"#常用集合\" class=\"headerlink\" title=\"常用集合\"></a>常用集合</h2><h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><p>实现：数组加链表，数组中的每一项是一个链表，通过计算存入对象的 HashCode，来计算对象在数组中要存入的位置，用链表来解决散列冲突，链表中的节点存储的是键值对。</p>\n<h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><p>1.7：使用 Segment 进行分段加锁，降低并发锁定；<br>1.8：使用 CAS 自旋锁的乐观锁来提高性能，但是在并发度较高时性能会比较一般</p>\n<h2 id=\"JUC\"><a href=\"#JUC\" class=\"headerlink\" title=\"JUC\"></a>JUC</h2><h3 id=\"原子类\"><a href=\"#原子类\" class=\"headerlink\" title=\"原子类\"></a>原子类</h3><p>例如：AtomicBoolean、AtomicLong、AtomicInteger、LongAdder、LongAccumulator等。<br>AtomicLong：通过 unsafe 类实现，基于CAS。<br>LongAdder：基于Cell，分段锁思想，空间换时间，更适合高并发场景。<br>LongAccumulator：提供了比LongAdder更强大的功能，能够指定对数据的操作规则，例如可以把对数据的相加操作改成相乘操作。</p>\n<h3 id=\"锁类\"><a href=\"#锁类\" class=\"headerlink\" title=\"锁类\"></a>锁类</h3><p>ReentrantLock<br>ReentrantReadWriteLock<br>StampedLock：JDK 1.8 改进的读写锁，是使用一种 CLH 的乐观锁，能够有效防止写饥饿。所谓写饥饿就是在多线程读写时，读线程访问非常频繁，导致总是有读线程占用资源，写线程很难加上写锁。<br>LockSupport</p>\n<h3 id=\"异步执行类\"><a href=\"#异步执行类\" class=\"headerlink\" title=\"异步执行类\"></a>异步执行类</h3><p>Executors：用于创建线程池<br>ForkJoinPool：1.7提供，采用分治思想，将大任务分解成多个小任务处理，然后在合并处理结果。特点是使用工作窃取算法，可以有效平衡多任务时间长短不一的场景。<br>FutureTask<br>CompletableFuture：可以支持流式调用，可以方便的进行多 future 的组合使用，例如可以同时执行两个异步任务，然后对执行结果进行合并处理。还可以很方便地设置完成时间。</p>\n<h3 id=\"阻塞队列类\"><a href=\"#阻塞队列类\" class=\"headerlink\" title=\"阻塞队列类\"></a>阻塞队列类</h3><p>LinkedBlockingDeque：双端队列，也就是可以分别从队头和队尾操作入队、出队。<br>ArrayBlockingQueue：单端队列，只能从队尾入队，队头出队。 </p>\n<h3 id=\"多线程协作类\"><a href=\"#多线程协作类\" class=\"headerlink\" title=\"多线程协作类\"></a>多线程协作类</h3><p>CountDownLatch：实现计数器功能，可以用来控制等待多个线程执行任务后进行汇总。<br>CyclicBarrier：可以让一组线程等待至某个状态之后，再全部同时执行，一般在测试时使用，可以让多线程更好的并发执行。<br>Semaphore：用来控制对共享资源的访问并发度。允许多个线程共享资源，适用于限制使用共享资源线程数量的场景，例如 100 个车辆要使用 20 个停车位，那么最多允许 20 个车占用停车位。</p>\n<h3 id=\"集合类\"><a href=\"#集合类\" class=\"headerlink\" title=\"集合类\"></a>集合类</h3><p>ConcurrentHashMap：线程安全的HashMap。<br>CopyOnWriteArrayList：通过写入数据时进行 copy 修改，然后更新引用的方式，来消除并行读写中的锁使用，比较适合读多写少，数据量比较小，但是并发非常高的场景。</p>\n<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><h3 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h3><h3 id=\"CGLIB动态代理\"><a href=\"#CGLIB动态代理\" class=\"headerlink\" title=\"CGLIB动态代理\"></a>CGLIB动态代理</h3><p>JDK 动态代理只能代理实现了接口的类或者直接代理接口；CGLIB 可以代理未实现任何接口的类，但不能代理声明为 final 类型的类和方法。</p>\n<h2 id=\"基础数据类型\"><a href=\"#基础数据类型\" class=\"headerlink\" title=\"基础数据类型\"></a>基础数据类型</h2><h2 id=\"对象引用\"><a href=\"#对象引用\" class=\"headerlink\" title=\"对象引用\"></a>对象引用</h2><h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><h2 id=\"SPI\"><a href=\"#SPI\" class=\"headerlink\" title=\"SPI\"></a>SPI</h2><h2 id=\"版本特性\"><a href=\"#版本特性\" class=\"headerlink\" title=\"版本特性\"></a>版本特性</h2>"},{"title":"JVM","_content":"\n架构师必备武器\n<!-- more -->\n\n# 内存模型\n\n## JVM内存模型\n\n## Java内存模型\n\n# 类加载\n\n# GC\n\n# 性能调优\n\n# 执行模式\n\n# 编译器优化\n","source":"_posts/20180619.md","raw":"---\ntitle: JVM\ncategory: 基础模块\n---\n\n架构师必备武器\n<!-- more -->\n\n# 内存模型\n\n## JVM内存模型\n\n## Java内存模型\n\n# 类加载\n\n# GC\n\n# 性能调优\n\n# 执行模式\n\n# 编译器优化\n","slug":"20180619","published":1,"date":"2021-07-29T02:57:29.332Z","updated":"2021-07-29T02:57:29.332Z","_id":"ckrnhewkr0006eg0mr3rdwfax","comments":1,"layout":"post","photos":[],"link":"","content":"<p>架构师必备武器<br><a id=\"more\"></a></p>\n<h1 id=\"内存模型\"><a href=\"#内存模型\" class=\"headerlink\" title=\"内存模型\"></a>内存模型</h1><h2 id=\"JVM内存模型\"><a href=\"#JVM内存模型\" class=\"headerlink\" title=\"JVM内存模型\"></a>JVM内存模型</h2><h2 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h2><h1 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h1><h1 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h1><h1 id=\"性能调优\"><a href=\"#性能调优\" class=\"headerlink\" title=\"性能调优\"></a>性能调优</h1><h1 id=\"执行模式\"><a href=\"#执行模式\" class=\"headerlink\" title=\"执行模式\"></a>执行模式</h1><h1 id=\"编译器优化\"><a href=\"#编译器优化\" class=\"headerlink\" title=\"编译器优化\"></a>编译器优化</h1>","site":{"data":{}},"excerpt":"<p>架构师必备武器<br>","more":"</p>\n<h1 id=\"内存模型\"><a href=\"#内存模型\" class=\"headerlink\" title=\"内存模型\"></a>内存模型</h1><h2 id=\"JVM内存模型\"><a href=\"#JVM内存模型\" class=\"headerlink\" title=\"JVM内存模型\"></a>JVM内存模型</h2><h2 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h2><h1 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h1><h1 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h1><h1 id=\"性能调优\"><a href=\"#性能调优\" class=\"headerlink\" title=\"性能调优\"></a>性能调优</h1><h1 id=\"执行模式\"><a href=\"#执行模式\" class=\"headerlink\" title=\"执行模式\"></a>执行模式</h1><h1 id=\"编译器优化\"><a href=\"#编译器优化\" class=\"headerlink\" title=\"编译器优化\"></a>编译器优化</h1>"},{"title":"并发与多线程","_content":"\n## 线程池\n线程池通过复用线程，避免线程频繁地创建和销毁。\n\n### 线程池任务执行流程\n提交任务的方法\nsubmit：可以返回一个 future 对象，通过 future 对象可以了解任务执行情况，可以取消任务的执行，还可获取执行结果或执行异常。\nexecute：submit 最终也是通过 execute 执行的。\n![img](http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6ABd8rAABJ5DF7U78658.png)\n1. 向线程池提交任务时，会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。\n2. 如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。\n3. 如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。\n4. 如果已经达到了最大线程数，则执行指定的拒绝策略\n\n### 创建线程池\nJava 的 Executors 工具类中提供了 5 种类型的线程池。\n\n* FixedThreadPool\n固定大小线程池，特点是线程数固定，使用无界队列。\n适用于任务数量不均匀的场景、对内存压力不敏感但系统负载比较敏感的场景。\n\n~~~java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n~~~\n\n* CachedThreadPool\nCached 线程池，特点是不限制线程数。\n适用于要求低延迟的短期任务场景。\n\n~~~java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n~~~\n\n* SingleThreadExecutor\n单线程线程池，就是一个线程的固定线程池。\n适用于需要异步执行但需要保证任务顺序的场景。\n\n~~~java\npublic static ScheduledExecutorService newSingleThreadScheduledExecutor() {\n    return new DelegatedScheduledExecutorService\n        (new ScheduledThreadPoolExecutor(1));\n}\n~~~\n\n* ScheduledThreadPool\nScheduled 线程池。\n适用于定期执行任务场景，支持按固定频率定期执行和按固定延时定期执行两种方式。\n\n~~~java\npublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n    return new ScheduledThreadPoolExecutor(corePoolSize);\n}\n\npublic ScheduledThreadPoolExecutor(int corePoolSize) {\n    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n          new DelayedWorkQueue());\n}\n~~~\n\n* WorkStealingPool\n工作窃取线程池，使用的是 ForkJoinPool，是固定并行度的多任务队列。\n适合任务执行时长不均匀的场景。\n\n~~~java\npublic static ExecutorService newWorkStealingPool(int parallelism) {\n     return new ForkJoinPool\n         (parallelism,\n          ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n          null, true);\n }\n~~~\n另外还可以根据业务需要自定义线程池，可使用 ThreadPoolExecutor(JUC工具类) 或 ThreadPoolTaskExecutor(Spring封装类) 。\n\n### 核心参数\n* 核心线程数\n* 最大线程数\n* 线程空闲时间和空闲时间的单位\n当线程闲置超过空闲时间就会被销毁。可以通过 allowCoreThreadTimeOut 方法来允许核心线程被回收。\n* 缓存队列\nArrayBlockingQueue: 有界队列，队列有最大容量限制\nLinkedBlockingQueue: 无界队列，队列不限制容量\nSynchronousQueue: 同步队列，内部没有缓冲区。\n* 线程工厂\n用来创建新线程，可以用来对线程的一些属性进行定制，例如线程的 group、线程名、优先级等，一般使用默认工厂类即可。\n\n~~~java\npublic class VehicleThreadFactory implements ThreadFactory {\n    private final ThreadGroup group;\n    private final AtomicInteger threadNumber = new AtomicInteger(1);\n    private final String prefix;\n    public VehicleThreadFactory(String name) {\n        SecurityManager s = System.getSecurityManager();\n        group = (s != null) ? s.getThreadGroup() :\n                Thread.currentThread().getThreadGroup();\n        prefix = name + \"-thread-\";\n    }\n    @Override\n    public Thread newThread(Runnable r) {\n        Thread t = new Thread(group, r,\n                prefix + threadNumber.getAndIncrement(),\n                0);\n        if (t.isDaemon()) {\n            t.setDaemon(false);\n        }\n        if (t.getPriority() != Thread.NORM_PRIORITY) {\n            t.setPriority(Thread.NORM_PRIORITY);\n        }\n        return t;\n    }\n}\n~~~\n* 拒绝策略\nAbort：默认策略，抛出 RejectedExecutionException 。\nDiscard：直接丢弃任务。\nCallerRuns：由提交任务的线程直接执行。\nDiscardOldest: 会丢弃最早提交的任务。\n也可以自定义策略，例如：\n~~~java\n(r, executor) -> {\n    try {\n        executor.getQueue().put(r);\n    } catch (InterruptedException e) {\n        log.warn(\"retry put task error,message:{}\", e);\n    }\n}\n~~~\n\n## 同步与互斥\n\n### synchronized\nsynchronized 应用在方法上时，在字节码中是通过方法的 **ACC_SYNCHRONIZED** 标志来实现的；\nsynchronized 应用在同步块上时，在字节码中是通过 **monitorenter** 和 **monitorexit** 实现的。\n最终都是通过对对象进行加锁，在 JVM 中，对象在内存中分为三块区域：对象头、实例数据和对齐填充。在对象头中保存了锁标志位和指向 monitor 对象的起始地址，当 Monitor 被某个线程持有后，就会处于锁定状态，此时 Owner 会指向持有 Monitor 对象的线程。Monitor 还有两个队列，用来存放进入及等待获取锁的线程。\nJVM对其进行了大量优化\n* 锁消除\n* 锁粗化\n* 自旋和自适应自旋\n* 锁升级\n无锁->偏向锁->轻量级锁->重量级锁\n### Lock\nAQS是实现Lock基础，AQS 有一个 state 标记位，值为1时表示有线程占用，其他线程需要进入到同步队列等待。\n![img](http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6ANLfHAAA3fj0S8po403.png)\n1. 当获得锁的线程需要等待某个条件时，会进入 condition 的等待队列，等待队列可以有多个。\n2. 当 condition 条件满足时，线程会从等待队列重新进入同步队列进行获取锁的竞争\n\n* ReentrantLock\n基于AQS实现，内部有公平锁和非公平锁两种实现，差别就在于新来的线程是否比已经在同步队列中的等待线程更早获得锁。\n* Semaphore\n基于AQS实现，差别在于 ReentrantLock 是独占锁，Semaphore 是共享锁。\n\n### CAS\n乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS。它认为并发操作并不总会发生。\n操作流程如下：其中比较并写回的操作是通过操作系统原语实现的，保证执行过程中不会被中断。\n1. 线程在读取数据时不进行加锁；\n2. 在准备写回数据时，比较原值是否修改；\n3. 若未被其他线程修改则写回；\n4. 若已被修改，则重新执行读取流程。\n\n缺点：容易出现ABA问题，不一定会影响结果，但还是需要防范，可以通过增加额外的标志位或者时间戳解决。JUC 工具包中提供了这样的类。\n![img](http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6AB5XwAAAWMnENBjk562.png)\n1. 线程 T1 读取值 A 之后，发生两次写入。\n2. 先由线程 T2 写回了 B\n3. 又由 T3 写回了 A\n4. 此时 T1 在写回比较时，值还是 A，就无法判断是否发生过修改。\n\nsynchronized 和 ReentrantLock 的区别：\n相同点：都是可重入、重量级锁。\n不同点：\n1. synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API。\n2. ReentrantLock 比 synchronized 增加了一些高级功能。例如：等待可中断、可实现公平锁、可绑定多个条件。\n使用场景：\n\n## 线程状态转换\n![img](http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI2Ab8rJAACvTREK08g324.png)\n1. 当创建一个线程时，线程处在 NEW 状态。\n2. 运行 Thread 的 start 方法后，线程进入 RUNNABLE 可运行状态，但线程此时是 READY 状态，就绪状态等待线程调度，在获取 CPU 后才能进入 RUNNING 运行状态。运行状态可以随着不同条件转换成除 NEW 以外的其他状态。\n3. 线程进入 synchronized 同步块或者同步方法时，如果获取锁失败，则会进入到 BLOCKED 状态，当获取到锁后，会从 BLOCKED 状态恢复到 RUNNABLE 可运行状态。\n4. 调用 Object.wait、Thread.join等，进入 TIMED_WAITING 有超时时间的等待状态。调用 Thread.join 或者 Locksupport.park 等，进入 WAITING 无超时的等待状态。均可以通过 notify 或 unpark 结束等待状态并恢复到RUNNABLE 可运行状态。\n5. 线程运行完成结束，进入 TERMINATED 状态。\n\n## 线程通信\n### wait\nwait 和 sleep 区别：\n* wait 属于 Object 类，sleep 属于 Thread 类；\n* wait 会释放锁对象，而 sleep 不会；\n* 使用的位置不同，wait 需要在同步块中使用，sleep 可以在任意地方；\n* sleep 需要捕获异常，而 wait 不需要。\n\n### notify\n### notifyAll\n\n## 死锁\n产生条件：\n* 互斥\n* 请求并持有\n* 非剥夺\n* 循环等待\n死锁检测与防止\n竞争条件与临界区\n\n## 机制\n### ThreadLocal\n用来解决线程数据隔离的问题，底层使用ThreadLocalMap保存线程变量。\n\n### Fork/Join\n用于大任务的分割与汇总\n\n### Volatile\n对多线程数据可见性的保证\n \n### Interrupt\n线程的中断机制","source":"_posts/20180630.md","raw":"---\ntitle: 并发与多线程\ncategory: 基础模块\n---\n\n## 线程池\n线程池通过复用线程，避免线程频繁地创建和销毁。\n\n### 线程池任务执行流程\n提交任务的方法\nsubmit：可以返回一个 future 对象，通过 future 对象可以了解任务执行情况，可以取消任务的执行，还可获取执行结果或执行异常。\nexecute：submit 最终也是通过 execute 执行的。\n![img](http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6ABd8rAABJ5DF7U78658.png)\n1. 向线程池提交任务时，会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。\n2. 如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。\n3. 如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。\n4. 如果已经达到了最大线程数，则执行指定的拒绝策略\n\n### 创建线程池\nJava 的 Executors 工具类中提供了 5 种类型的线程池。\n\n* FixedThreadPool\n固定大小线程池，特点是线程数固定，使用无界队列。\n适用于任务数量不均匀的场景、对内存压力不敏感但系统负载比较敏感的场景。\n\n~~~java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n~~~\n\n* CachedThreadPool\nCached 线程池，特点是不限制线程数。\n适用于要求低延迟的短期任务场景。\n\n~~~java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n~~~\n\n* SingleThreadExecutor\n单线程线程池，就是一个线程的固定线程池。\n适用于需要异步执行但需要保证任务顺序的场景。\n\n~~~java\npublic static ScheduledExecutorService newSingleThreadScheduledExecutor() {\n    return new DelegatedScheduledExecutorService\n        (new ScheduledThreadPoolExecutor(1));\n}\n~~~\n\n* ScheduledThreadPool\nScheduled 线程池。\n适用于定期执行任务场景，支持按固定频率定期执行和按固定延时定期执行两种方式。\n\n~~~java\npublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n    return new ScheduledThreadPoolExecutor(corePoolSize);\n}\n\npublic ScheduledThreadPoolExecutor(int corePoolSize) {\n    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n          new DelayedWorkQueue());\n}\n~~~\n\n* WorkStealingPool\n工作窃取线程池，使用的是 ForkJoinPool，是固定并行度的多任务队列。\n适合任务执行时长不均匀的场景。\n\n~~~java\npublic static ExecutorService newWorkStealingPool(int parallelism) {\n     return new ForkJoinPool\n         (parallelism,\n          ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n          null, true);\n }\n~~~\n另外还可以根据业务需要自定义线程池，可使用 ThreadPoolExecutor(JUC工具类) 或 ThreadPoolTaskExecutor(Spring封装类) 。\n\n### 核心参数\n* 核心线程数\n* 最大线程数\n* 线程空闲时间和空闲时间的单位\n当线程闲置超过空闲时间就会被销毁。可以通过 allowCoreThreadTimeOut 方法来允许核心线程被回收。\n* 缓存队列\nArrayBlockingQueue: 有界队列，队列有最大容量限制\nLinkedBlockingQueue: 无界队列，队列不限制容量\nSynchronousQueue: 同步队列，内部没有缓冲区。\n* 线程工厂\n用来创建新线程，可以用来对线程的一些属性进行定制，例如线程的 group、线程名、优先级等，一般使用默认工厂类即可。\n\n~~~java\npublic class VehicleThreadFactory implements ThreadFactory {\n    private final ThreadGroup group;\n    private final AtomicInteger threadNumber = new AtomicInteger(1);\n    private final String prefix;\n    public VehicleThreadFactory(String name) {\n        SecurityManager s = System.getSecurityManager();\n        group = (s != null) ? s.getThreadGroup() :\n                Thread.currentThread().getThreadGroup();\n        prefix = name + \"-thread-\";\n    }\n    @Override\n    public Thread newThread(Runnable r) {\n        Thread t = new Thread(group, r,\n                prefix + threadNumber.getAndIncrement(),\n                0);\n        if (t.isDaemon()) {\n            t.setDaemon(false);\n        }\n        if (t.getPriority() != Thread.NORM_PRIORITY) {\n            t.setPriority(Thread.NORM_PRIORITY);\n        }\n        return t;\n    }\n}\n~~~\n* 拒绝策略\nAbort：默认策略，抛出 RejectedExecutionException 。\nDiscard：直接丢弃任务。\nCallerRuns：由提交任务的线程直接执行。\nDiscardOldest: 会丢弃最早提交的任务。\n也可以自定义策略，例如：\n~~~java\n(r, executor) -> {\n    try {\n        executor.getQueue().put(r);\n    } catch (InterruptedException e) {\n        log.warn(\"retry put task error,message:{}\", e);\n    }\n}\n~~~\n\n## 同步与互斥\n\n### synchronized\nsynchronized 应用在方法上时，在字节码中是通过方法的 **ACC_SYNCHRONIZED** 标志来实现的；\nsynchronized 应用在同步块上时，在字节码中是通过 **monitorenter** 和 **monitorexit** 实现的。\n最终都是通过对对象进行加锁，在 JVM 中，对象在内存中分为三块区域：对象头、实例数据和对齐填充。在对象头中保存了锁标志位和指向 monitor 对象的起始地址，当 Monitor 被某个线程持有后，就会处于锁定状态，此时 Owner 会指向持有 Monitor 对象的线程。Monitor 还有两个队列，用来存放进入及等待获取锁的线程。\nJVM对其进行了大量优化\n* 锁消除\n* 锁粗化\n* 自旋和自适应自旋\n* 锁升级\n无锁->偏向锁->轻量级锁->重量级锁\n### Lock\nAQS是实现Lock基础，AQS 有一个 state 标记位，值为1时表示有线程占用，其他线程需要进入到同步队列等待。\n![img](http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6ANLfHAAA3fj0S8po403.png)\n1. 当获得锁的线程需要等待某个条件时，会进入 condition 的等待队列，等待队列可以有多个。\n2. 当 condition 条件满足时，线程会从等待队列重新进入同步队列进行获取锁的竞争\n\n* ReentrantLock\n基于AQS实现，内部有公平锁和非公平锁两种实现，差别就在于新来的线程是否比已经在同步队列中的等待线程更早获得锁。\n* Semaphore\n基于AQS实现，差别在于 ReentrantLock 是独占锁，Semaphore 是共享锁。\n\n### CAS\n乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS。它认为并发操作并不总会发生。\n操作流程如下：其中比较并写回的操作是通过操作系统原语实现的，保证执行过程中不会被中断。\n1. 线程在读取数据时不进行加锁；\n2. 在准备写回数据时，比较原值是否修改；\n3. 若未被其他线程修改则写回；\n4. 若已被修改，则重新执行读取流程。\n\n缺点：容易出现ABA问题，不一定会影响结果，但还是需要防范，可以通过增加额外的标志位或者时间戳解决。JUC 工具包中提供了这样的类。\n![img](http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6AB5XwAAAWMnENBjk562.png)\n1. 线程 T1 读取值 A 之后，发生两次写入。\n2. 先由线程 T2 写回了 B\n3. 又由 T3 写回了 A\n4. 此时 T1 在写回比较时，值还是 A，就无法判断是否发生过修改。\n\nsynchronized 和 ReentrantLock 的区别：\n相同点：都是可重入、重量级锁。\n不同点：\n1. synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API。\n2. ReentrantLock 比 synchronized 增加了一些高级功能。例如：等待可中断、可实现公平锁、可绑定多个条件。\n使用场景：\n\n## 线程状态转换\n![img](http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI2Ab8rJAACvTREK08g324.png)\n1. 当创建一个线程时，线程处在 NEW 状态。\n2. 运行 Thread 的 start 方法后，线程进入 RUNNABLE 可运行状态，但线程此时是 READY 状态，就绪状态等待线程调度，在获取 CPU 后才能进入 RUNNING 运行状态。运行状态可以随着不同条件转换成除 NEW 以外的其他状态。\n3. 线程进入 synchronized 同步块或者同步方法时，如果获取锁失败，则会进入到 BLOCKED 状态，当获取到锁后，会从 BLOCKED 状态恢复到 RUNNABLE 可运行状态。\n4. 调用 Object.wait、Thread.join等，进入 TIMED_WAITING 有超时时间的等待状态。调用 Thread.join 或者 Locksupport.park 等，进入 WAITING 无超时的等待状态。均可以通过 notify 或 unpark 结束等待状态并恢复到RUNNABLE 可运行状态。\n5. 线程运行完成结束，进入 TERMINATED 状态。\n\n## 线程通信\n### wait\nwait 和 sleep 区别：\n* wait 属于 Object 类，sleep 属于 Thread 类；\n* wait 会释放锁对象，而 sleep 不会；\n* 使用的位置不同，wait 需要在同步块中使用，sleep 可以在任意地方；\n* sleep 需要捕获异常，而 wait 不需要。\n\n### notify\n### notifyAll\n\n## 死锁\n产生条件：\n* 互斥\n* 请求并持有\n* 非剥夺\n* 循环等待\n死锁检测与防止\n竞争条件与临界区\n\n## 机制\n### ThreadLocal\n用来解决线程数据隔离的问题，底层使用ThreadLocalMap保存线程变量。\n\n### Fork/Join\n用于大任务的分割与汇总\n\n### Volatile\n对多线程数据可见性的保证\n \n### Interrupt\n线程的中断机制","slug":"20180630","published":1,"date":"2021-07-29T02:57:29.334Z","updated":"2021-07-29T06:30:14.263Z","_id":"ckrnhewkr0007eg0mbhwhf3gw","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>线程池通过复用线程，避免线程频繁地创建和销毁。</p>\n<h3 id=\"线程池任务执行流程\"><a href=\"#线程池任务执行流程\" class=\"headerlink\" title=\"线程池任务执行流程\"></a>线程池任务执行流程</h3><p>提交任务的方法<br>submit：可以返回一个 future 对象，通过 future 对象可以了解任务执行情况，可以取消任务的执行，还可获取执行结果或执行异常。<br>execute：submit 最终也是通过 execute 执行的。<br><img src=\"http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6ABd8rAABJ5DF7U78658.png\" alt=\"img\"></p>\n<ol>\n<li>向线程池提交任务时，会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。</li>\n<li>如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。</li>\n<li>如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。</li>\n<li>如果已经达到了最大线程数，则执行指定的拒绝策略</li>\n</ol>\n<h3 id=\"创建线程池\"><a href=\"#创建线程池\" class=\"headerlink\" title=\"创建线程池\"></a>创建线程池</h3><p>Java 的 Executors 工具类中提供了 5 种类型的线程池。</p>\n<ul>\n<li>FixedThreadPool<br>固定大小线程池，特点是线程数固定，使用无界队列。<br>适用于任务数量不均匀的场景、对内存压力不敏感但系统负载比较敏感的场景。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class=\"line\">                                  <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</div><div class=\"line\">                                  <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>CachedThreadPool<br>Cached 线程池，特点是不限制线程数。<br>适用于要求低延迟的短期任务场景。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE,</div><div class=\"line\">                                  <span class=\"number\">60L</span>, TimeUnit.SECONDS,</div><div class=\"line\">                                  <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>SingleThreadExecutor<br>单线程线程池，就是一个线程的固定线程池。<br>适用于需要异步执行但需要保证任务顺序的场景。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newSingleThreadScheduledExecutor</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DelegatedScheduledExecutorService</div><div class=\"line\">        (<span class=\"keyword\">new</span> ScheduledThreadPoolExecutor(<span class=\"number\">1</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>ScheduledThreadPool<br>Scheduled 线程池。<br>适用于定期执行任务场景，支持按固定频率定期执行和按固定延时定期执行两种方式。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ScheduledThreadPoolExecutor(corePoolSize);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScheduledThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(corePoolSize, Integer.MAX_VALUE, <span class=\"number\">0</span>, NANOSECONDS,</div><div class=\"line\">          <span class=\"keyword\">new</span> DelayedWorkQueue());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>WorkStealingPool<br>工作窃取线程池，使用的是 ForkJoinPool，是固定并行度的多任务队列。<br>适合任务执行时长不均匀的场景。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newWorkStealingPool</span><span class=\"params\">(<span class=\"keyword\">int</span> parallelism)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ForkJoinPool</div><div class=\"line\">         (parallelism,</div><div class=\"line\">          ForkJoinPool.defaultForkJoinWorkerThreadFactory,</div><div class=\"line\">          <span class=\"keyword\">null</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>另外还可以根据业务需要自定义线程池，可使用 ThreadPoolExecutor(JUC工具类) 或 ThreadPoolTaskExecutor(Spring封装类) 。</p>\n<h3 id=\"核心参数\"><a href=\"#核心参数\" class=\"headerlink\" title=\"核心参数\"></a>核心参数</h3><ul>\n<li>核心线程数</li>\n<li>最大线程数</li>\n<li>线程空闲时间和空闲时间的单位<br>当线程闲置超过空闲时间就会被销毁。可以通过 allowCoreThreadTimeOut 方法来允许核心线程被回收。</li>\n<li>缓存队列<br>ArrayBlockingQueue: 有界队列，队列有最大容量限制<br>LinkedBlockingQueue: 无界队列，队列不限制容量<br>SynchronousQueue: 同步队列，内部没有缓冲区。</li>\n<li>线程工厂<br>用来创建新线程，可以用来对线程的一些属性进行定制，例如线程的 group、线程名、优先级等，一般使用默认工厂类即可。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VehicleThreadFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ThreadFactory</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadGroup group;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger threadNumber = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String prefix;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">VehicleThreadFactory</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        SecurityManager s = System.getSecurityManager();</div><div class=\"line\">        group = (s != <span class=\"keyword\">null</span>) ? s.getThreadGroup() :</div><div class=\"line\">                Thread.currentThread().getThreadGroup();</div><div class=\"line\">        prefix = name + <span class=\"string\">\"-thread-\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</div><div class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread(group, r,</div><div class=\"line\">                prefix + threadNumber.getAndIncrement(),</div><div class=\"line\">                <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (t.isDaemon()) &#123;</div><div class=\"line\">            t.setDaemon(<span class=\"keyword\">false</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (t.getPriority() != Thread.NORM_PRIORITY) &#123;</div><div class=\"line\">            t.setPriority(Thread.NORM_PRIORITY);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> t;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>拒绝策略<br>Abort：默认策略，抛出 RejectedExecutionException 。<br>Discard：直接丢弃任务。<br>CallerRuns：由提交任务的线程直接执行。<br>DiscardOldest: 会丢弃最早提交的任务。<br>也可以自定义策略，例如：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(r, executor) -&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        executor.getQueue().put(r);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">        log.warn(<span class=\"string\">\"retry put task error,message:&#123;&#125;\"</span>, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"同步与互斥\"><a href=\"#同步与互斥\" class=\"headerlink\" title=\"同步与互斥\"></a>同步与互斥</h2><h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><p>synchronized 应用在方法上时，在字节码中是通过方法的 <strong>ACC_SYNCHRONIZED</strong> 标志来实现的；<br>synchronized 应用在同步块上时，在字节码中是通过 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 实现的。<br>最终都是通过对对象进行加锁，在 JVM 中，对象在内存中分为三块区域：对象头、实例数据和对齐填充。在对象头中保存了锁标志位和指向 monitor 对象的起始地址，当 Monitor 被某个线程持有后，就会处于锁定状态，此时 Owner 会指向持有 Monitor 对象的线程。Monitor 还有两个队列，用来存放进入及等待获取锁的线程。<br>JVM对其进行了大量优化</p>\n<ul>\n<li>锁消除</li>\n<li>锁粗化</li>\n<li>自旋和自适应自旋</li>\n<li>锁升级<br>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁<h3 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h3>AQS是实现Lock基础，AQS 有一个 state 标记位，值为1时表示有线程占用，其他线程需要进入到同步队列等待。<br><img src=\"http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6ANLfHAAA3fj0S8po403.png\" alt=\"img\"></li>\n</ul>\n<ol>\n<li>当获得锁的线程需要等待某个条件时，会进入 condition 的等待队列，等待队列可以有多个。</li>\n<li>当 condition 条件满足时，线程会从等待队列重新进入同步队列进行获取锁的竞争</li>\n</ol>\n<ul>\n<li>ReentrantLock<br>基于AQS实现，内部有公平锁和非公平锁两种实现，差别就在于新来的线程是否比已经在同步队列中的等待线程更早获得锁。</li>\n<li>Semaphore<br>基于AQS实现，差别在于 ReentrantLock 是独占锁，Semaphore 是共享锁。</li>\n</ul>\n<h3 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h3><p>乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS。它认为并发操作并不总会发生。<br>操作流程如下：其中比较并写回的操作是通过操作系统原语实现的，保证执行过程中不会被中断。</p>\n<ol>\n<li>线程在读取数据时不进行加锁；</li>\n<li>在准备写回数据时，比较原值是否修改；</li>\n<li>若未被其他线程修改则写回；</li>\n<li>若已被修改，则重新执行读取流程。</li>\n</ol>\n<p>缺点：容易出现ABA问题，不一定会影响结果，但还是需要防范，可以通过增加额外的标志位或者时间戳解决。JUC 工具包中提供了这样的类。<br><img src=\"http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6AB5XwAAAWMnENBjk562.png\" alt=\"img\"></p>\n<ol>\n<li>线程 T1 读取值 A 之后，发生两次写入。</li>\n<li>先由线程 T2 写回了 B</li>\n<li>又由 T3 写回了 A</li>\n<li>此时 T1 在写回比较时，值还是 A，就无法判断是否发生过修改。</li>\n</ol>\n<p>synchronized 和 ReentrantLock 的区别：<br>相同点：都是可重入、重量级锁。<br>不同点：</p>\n<ol>\n<li>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API。</li>\n<li>ReentrantLock 比 synchronized 增加了一些高级功能。例如：等待可中断、可实现公平锁、可绑定多个条件。<br>使用场景：</li>\n</ol>\n<h2 id=\"线程状态转换\"><a href=\"#线程状态转换\" class=\"headerlink\" title=\"线程状态转换\"></a>线程状态转换</h2><p><img src=\"http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI2Ab8rJAACvTREK08g324.png\" alt=\"img\"></p>\n<ol>\n<li>当创建一个线程时，线程处在 NEW 状态。</li>\n<li>运行 Thread 的 start 方法后，线程进入 RUNNABLE 可运行状态，但线程此时是 READY 状态，就绪状态等待线程调度，在获取 CPU 后才能进入 RUNNING 运行状态。运行状态可以随着不同条件转换成除 NEW 以外的其他状态。</li>\n<li>线程进入 synchronized 同步块或者同步方法时，如果获取锁失败，则会进入到 BLOCKED 状态，当获取到锁后，会从 BLOCKED 状态恢复到 RUNNABLE 可运行状态。</li>\n<li>调用 Object.wait、Thread.join等，进入 TIMED_WAITING 有超时时间的等待状态。调用 Thread.join 或者 Locksupport.park 等，进入 WAITING 无超时的等待状态。均可以通过 notify 或 unpark 结束等待状态并恢复到RUNNABLE 可运行状态。</li>\n<li>线程运行完成结束，进入 TERMINATED 状态。</li>\n</ol>\n<h2 id=\"线程通信\"><a href=\"#线程通信\" class=\"headerlink\" title=\"线程通信\"></a>线程通信</h2><h3 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait\"></a>wait</h3><p>wait 和 sleep 区别：</p>\n<ul>\n<li>wait 属于 Object 类，sleep 属于 Thread 类；</li>\n<li>wait 会释放锁对象，而 sleep 不会；</li>\n<li>使用的位置不同，wait 需要在同步块中使用，sleep 可以在任意地方；</li>\n<li>sleep 需要捕获异常，而 wait 不需要。</li>\n</ul>\n<h3 id=\"notify\"><a href=\"#notify\" class=\"headerlink\" title=\"notify\"></a>notify</h3><h3 id=\"notifyAll\"><a href=\"#notifyAll\" class=\"headerlink\" title=\"notifyAll\"></a>notifyAll</h3><h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>产生条件：</p>\n<ul>\n<li>互斥</li>\n<li>请求并持有</li>\n<li>非剥夺</li>\n<li>循环等待<br>死锁检测与防止<br>竞争条件与临界区</li>\n</ul>\n<h2 id=\"机制\"><a href=\"#机制\" class=\"headerlink\" title=\"机制\"></a>机制</h2><h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>用来解决线程数据隔离的问题，底层使用ThreadLocalMap保存线程变量。</p>\n<h3 id=\"Fork-Join\"><a href=\"#Fork-Join\" class=\"headerlink\" title=\"Fork/Join\"></a>Fork/Join</h3><p>用于大任务的分割与汇总</p>\n<h3 id=\"Volatile\"><a href=\"#Volatile\" class=\"headerlink\" title=\"Volatile\"></a>Volatile</h3><p>对多线程数据可见性的保证</p>\n<h3 id=\"Interrupt\"><a href=\"#Interrupt\" class=\"headerlink\" title=\"Interrupt\"></a>Interrupt</h3><p>线程的中断机制</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>线程池通过复用线程，避免线程频繁地创建和销毁。</p>\n<h3 id=\"线程池任务执行流程\"><a href=\"#线程池任务执行流程\" class=\"headerlink\" title=\"线程池任务执行流程\"></a>线程池任务执行流程</h3><p>提交任务的方法<br>submit：可以返回一个 future 对象，通过 future 对象可以了解任务执行情况，可以取消任务的执行，还可获取执行结果或执行异常。<br>execute：submit 最终也是通过 execute 执行的。<br><img src=\"http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6ABd8rAABJ5DF7U78658.png\" alt=\"img\"></p>\n<ol>\n<li>向线程池提交任务时，会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。</li>\n<li>如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。</li>\n<li>如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。</li>\n<li>如果已经达到了最大线程数，则执行指定的拒绝策略</li>\n</ol>\n<h3 id=\"创建线程池\"><a href=\"#创建线程池\" class=\"headerlink\" title=\"创建线程池\"></a>创建线程池</h3><p>Java 的 Executors 工具类中提供了 5 种类型的线程池。</p>\n<ul>\n<li>FixedThreadPool<br>固定大小线程池，特点是线程数固定，使用无界队列。<br>适用于任务数量不均匀的场景、对内存压力不敏感但系统负载比较敏感的场景。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class=\"line\">                                  <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</div><div class=\"line\">                                  <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>CachedThreadPool<br>Cached 线程池，特点是不限制线程数。<br>适用于要求低延迟的短期任务场景。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE,</div><div class=\"line\">                                  <span class=\"number\">60L</span>, TimeUnit.SECONDS,</div><div class=\"line\">                                  <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>SingleThreadExecutor<br>单线程线程池，就是一个线程的固定线程池。<br>适用于需要异步执行但需要保证任务顺序的场景。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newSingleThreadScheduledExecutor</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DelegatedScheduledExecutorService</div><div class=\"line\">        (<span class=\"keyword\">new</span> ScheduledThreadPoolExecutor(<span class=\"number\">1</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>ScheduledThreadPool<br>Scheduled 线程池。<br>适用于定期执行任务场景，支持按固定频率定期执行和按固定延时定期执行两种方式。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ScheduledThreadPoolExecutor(corePoolSize);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScheduledThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(corePoolSize, Integer.MAX_VALUE, <span class=\"number\">0</span>, NANOSECONDS,</div><div class=\"line\">          <span class=\"keyword\">new</span> DelayedWorkQueue());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>WorkStealingPool<br>工作窃取线程池，使用的是 ForkJoinPool，是固定并行度的多任务队列。<br>适合任务执行时长不均匀的场景。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newWorkStealingPool</span><span class=\"params\">(<span class=\"keyword\">int</span> parallelism)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ForkJoinPool</div><div class=\"line\">         (parallelism,</div><div class=\"line\">          ForkJoinPool.defaultForkJoinWorkerThreadFactory,</div><div class=\"line\">          <span class=\"keyword\">null</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>另外还可以根据业务需要自定义线程池，可使用 ThreadPoolExecutor(JUC工具类) 或 ThreadPoolTaskExecutor(Spring封装类) 。</p>\n<h3 id=\"核心参数\"><a href=\"#核心参数\" class=\"headerlink\" title=\"核心参数\"></a>核心参数</h3><ul>\n<li>核心线程数</li>\n<li>最大线程数</li>\n<li>线程空闲时间和空闲时间的单位<br>当线程闲置超过空闲时间就会被销毁。可以通过 allowCoreThreadTimeOut 方法来允许核心线程被回收。</li>\n<li>缓存队列<br>ArrayBlockingQueue: 有界队列，队列有最大容量限制<br>LinkedBlockingQueue: 无界队列，队列不限制容量<br>SynchronousQueue: 同步队列，内部没有缓冲区。</li>\n<li>线程工厂<br>用来创建新线程，可以用来对线程的一些属性进行定制，例如线程的 group、线程名、优先级等，一般使用默认工厂类即可。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VehicleThreadFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ThreadFactory</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadGroup group;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger threadNumber = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String prefix;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">VehicleThreadFactory</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        SecurityManager s = System.getSecurityManager();</div><div class=\"line\">        group = (s != <span class=\"keyword\">null</span>) ? s.getThreadGroup() :</div><div class=\"line\">                Thread.currentThread().getThreadGroup();</div><div class=\"line\">        prefix = name + <span class=\"string\">\"-thread-\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</div><div class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread(group, r,</div><div class=\"line\">                prefix + threadNumber.getAndIncrement(),</div><div class=\"line\">                <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (t.isDaemon()) &#123;</div><div class=\"line\">            t.setDaemon(<span class=\"keyword\">false</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (t.getPriority() != Thread.NORM_PRIORITY) &#123;</div><div class=\"line\">            t.setPriority(Thread.NORM_PRIORITY);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> t;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>拒绝策略<br>Abort：默认策略，抛出 RejectedExecutionException 。<br>Discard：直接丢弃任务。<br>CallerRuns：由提交任务的线程直接执行。<br>DiscardOldest: 会丢弃最早提交的任务。<br>也可以自定义策略，例如：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(r, executor) -&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        executor.getQueue().put(r);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">        log.warn(<span class=\"string\">\"retry put task error,message:&#123;&#125;\"</span>, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"同步与互斥\"><a href=\"#同步与互斥\" class=\"headerlink\" title=\"同步与互斥\"></a>同步与互斥</h2><h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><p>synchronized 应用在方法上时，在字节码中是通过方法的 <strong>ACC_SYNCHRONIZED</strong> 标志来实现的；<br>synchronized 应用在同步块上时，在字节码中是通过 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 实现的。<br>最终都是通过对对象进行加锁，在 JVM 中，对象在内存中分为三块区域：对象头、实例数据和对齐填充。在对象头中保存了锁标志位和指向 monitor 对象的起始地址，当 Monitor 被某个线程持有后，就会处于锁定状态，此时 Owner 会指向持有 Monitor 对象的线程。Monitor 还有两个队列，用来存放进入及等待获取锁的线程。<br>JVM对其进行了大量优化</p>\n<ul>\n<li>锁消除</li>\n<li>锁粗化</li>\n<li>自旋和自适应自旋</li>\n<li>锁升级<br>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁<h3 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h3>AQS是实现Lock基础，AQS 有一个 state 标记位，值为1时表示有线程占用，其他线程需要进入到同步队列等待。<br><img src=\"http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6ANLfHAAA3fj0S8po403.png\" alt=\"img\"></li>\n</ul>\n<ol>\n<li>当获得锁的线程需要等待某个条件时，会进入 condition 的等待队列，等待队列可以有多个。</li>\n<li>当 condition 条件满足时，线程会从等待队列重新进入同步队列进行获取锁的竞争</li>\n</ol>\n<ul>\n<li>ReentrantLock<br>基于AQS实现，内部有公平锁和非公平锁两种实现，差别就在于新来的线程是否比已经在同步队列中的等待线程更早获得锁。</li>\n<li>Semaphore<br>基于AQS实现，差别在于 ReentrantLock 是独占锁，Semaphore 是共享锁。</li>\n</ul>\n<h3 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h3><p>乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS。它认为并发操作并不总会发生。<br>操作流程如下：其中比较并写回的操作是通过操作系统原语实现的，保证执行过程中不会被中断。</p>\n<ol>\n<li>线程在读取数据时不进行加锁；</li>\n<li>在准备写回数据时，比较原值是否修改；</li>\n<li>若未被其他线程修改则写回；</li>\n<li>若已被修改，则重新执行读取流程。</li>\n</ol>\n<p>缺点：容易出现ABA问题，不一定会影响结果，但还是需要防范，可以通过增加额外的标志位或者时间戳解决。JUC 工具包中提供了这样的类。<br><img src=\"http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6AB5XwAAAWMnENBjk562.png\" alt=\"img\"></p>\n<ol>\n<li>线程 T1 读取值 A 之后，发生两次写入。</li>\n<li>先由线程 T2 写回了 B</li>\n<li>又由 T3 写回了 A</li>\n<li>此时 T1 在写回比较时，值还是 A，就无法判断是否发生过修改。</li>\n</ol>\n<p>synchronized 和 ReentrantLock 的区别：<br>相同点：都是可重入、重量级锁。<br>不同点：</p>\n<ol>\n<li>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API。</li>\n<li>ReentrantLock 比 synchronized 增加了一些高级功能。例如：等待可中断、可实现公平锁、可绑定多个条件。<br>使用场景：</li>\n</ol>\n<h2 id=\"线程状态转换\"><a href=\"#线程状态转换\" class=\"headerlink\" title=\"线程状态转换\"></a>线程状态转换</h2><p><img src=\"http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI2Ab8rJAACvTREK08g324.png\" alt=\"img\"></p>\n<ol>\n<li>当创建一个线程时，线程处在 NEW 状态。</li>\n<li>运行 Thread 的 start 方法后，线程进入 RUNNABLE 可运行状态，但线程此时是 READY 状态，就绪状态等待线程调度，在获取 CPU 后才能进入 RUNNING 运行状态。运行状态可以随着不同条件转换成除 NEW 以外的其他状态。</li>\n<li>线程进入 synchronized 同步块或者同步方法时，如果获取锁失败，则会进入到 BLOCKED 状态，当获取到锁后，会从 BLOCKED 状态恢复到 RUNNABLE 可运行状态。</li>\n<li>调用 Object.wait、Thread.join等，进入 TIMED_WAITING 有超时时间的等待状态。调用 Thread.join 或者 Locksupport.park 等，进入 WAITING 无超时的等待状态。均可以通过 notify 或 unpark 结束等待状态并恢复到RUNNABLE 可运行状态。</li>\n<li>线程运行完成结束，进入 TERMINATED 状态。</li>\n</ol>\n<h2 id=\"线程通信\"><a href=\"#线程通信\" class=\"headerlink\" title=\"线程通信\"></a>线程通信</h2><h3 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait\"></a>wait</h3><p>wait 和 sleep 区别：</p>\n<ul>\n<li>wait 属于 Object 类，sleep 属于 Thread 类；</li>\n<li>wait 会释放锁对象，而 sleep 不会；</li>\n<li>使用的位置不同，wait 需要在同步块中使用，sleep 可以在任意地方；</li>\n<li>sleep 需要捕获异常，而 wait 不需要。</li>\n</ul>\n<h3 id=\"notify\"><a href=\"#notify\" class=\"headerlink\" title=\"notify\"></a>notify</h3><h3 id=\"notifyAll\"><a href=\"#notifyAll\" class=\"headerlink\" title=\"notifyAll\"></a>notifyAll</h3><h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>产生条件：</p>\n<ul>\n<li>互斥</li>\n<li>请求并持有</li>\n<li>非剥夺</li>\n<li>循环等待<br>死锁检测与防止<br>竞争条件与临界区</li>\n</ul>\n<h2 id=\"机制\"><a href=\"#机制\" class=\"headerlink\" title=\"机制\"></a>机制</h2><h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>用来解决线程数据隔离的问题，底层使用ThreadLocalMap保存线程变量。</p>\n<h3 id=\"Fork-Join\"><a href=\"#Fork-Join\" class=\"headerlink\" title=\"Fork/Join\"></a>Fork/Join</h3><p>用于大任务的分割与汇总</p>\n<h3 id=\"Volatile\"><a href=\"#Volatile\" class=\"headerlink\" title=\"Volatile\"></a>Volatile</h3><p>对多线程数据可见性的保证</p>\n<h3 id=\"Interrupt\"><a href=\"#Interrupt\" class=\"headerlink\" title=\"Interrupt\"></a>Interrupt</h3><p>线程的中断机制</p>\n"},{"title":"数据结构与算法","_content":"\n# 数据结构\n\n# 算法\n\n## 复杂度\n\n## 排序\n\n## 查找\n\n## 字符串匹配\n\n## 常用算法思路\n\n\n","source":"_posts/20180720.md","raw":"---\ntitle: 数据结构与算法\ncategory: 基础模块\n---\n\n# 数据结构\n\n# 算法\n\n## 复杂度\n\n## 排序\n\n## 查找\n\n## 字符串匹配\n\n## 常用算法思路\n\n\n","slug":"20180720","published":1,"date":"2021-07-29T02:57:29.335Z","updated":"2021-07-29T02:57:29.335Z","_id":"ckrnhewks0008eg0mnwpks1wh","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><h2 id=\"字符串匹配\"><a href=\"#字符串匹配\" class=\"headerlink\" title=\"字符串匹配\"></a>字符串匹配</h2><h2 id=\"常用算法思路\"><a href=\"#常用算法思路\" class=\"headerlink\" title=\"常用算法思路\"></a>常用算法思路</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><h2 id=\"字符串匹配\"><a href=\"#字符串匹配\" class=\"headerlink\" title=\"字符串匹配\"></a>字符串匹配</h2><h2 id=\"常用算法思路\"><a href=\"#常用算法思路\" class=\"headerlink\" title=\"常用算法思路\"></a>常用算法思路</h2>"},{"title":"常用工具集","_content":"\n## 团队协作\n* Git\n* SVN\n\n## 质量保证\n\n## 压测\n* JMeter\n\n## 容器与代理\n\n## 文档管理\n* confluence\n\n## 网络","source":"_posts/20180725.md","raw":"---\ntitle: 常用工具集\ncategory: 应用模块\n---\n\n## 团队协作\n* Git\n* SVN\n\n## 质量保证\n\n## 压测\n* JMeter\n\n## 容器与代理\n\n## 文档管理\n* confluence\n\n## 网络","slug":"20180725","published":1,"date":"2021-07-29T02:57:29.336Z","updated":"2021-07-29T03:09:23.619Z","_id":"ckrnhewkt0009eg0mqm1lw41y","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"团队协作\"><a href=\"#团队协作\" class=\"headerlink\" title=\"团队协作\"></a>团队协作</h2><ul>\n<li>Git</li>\n<li>SVN</li>\n</ul>\n<h2 id=\"质量保证\"><a href=\"#质量保证\" class=\"headerlink\" title=\"质量保证\"></a>质量保证</h2><h2 id=\"压测\"><a href=\"#压测\" class=\"headerlink\" title=\"压测\"></a>压测</h2><ul>\n<li>JMeter</li>\n</ul>\n<h2 id=\"容器与代理\"><a href=\"#容器与代理\" class=\"headerlink\" title=\"容器与代理\"></a>容器与代理</h2><h2 id=\"文档管理\"><a href=\"#文档管理\" class=\"headerlink\" title=\"文档管理\"></a>文档管理</h2><ul>\n<li>confluence</li>\n</ul>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"团队协作\"><a href=\"#团队协作\" class=\"headerlink\" title=\"团队协作\"></a>团队协作</h2><ul>\n<li>Git</li>\n<li>SVN</li>\n</ul>\n<h2 id=\"质量保证\"><a href=\"#质量保证\" class=\"headerlink\" title=\"质量保证\"></a>质量保证</h2><h2 id=\"压测\"><a href=\"#压测\" class=\"headerlink\" title=\"压测\"></a>压测</h2><ul>\n<li>JMeter</li>\n</ul>\n<h2 id=\"容器与代理\"><a href=\"#容器与代理\" class=\"headerlink\" title=\"容器与代理\"></a>容器与代理</h2><h2 id=\"文档管理\"><a href=\"#文档管理\" class=\"headerlink\" title=\"文档管理\"></a>文档管理</h2><ul>\n<li>confluence</li>\n</ul>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2>"},{"title":"Spring","_content":"\n# Spring Framework\n\n## Context初始化流程\n~~~java\npublic void refresh() throws BeansException, IllegalStateException {\n    synchronized (this.startupShutdownMonitor) {\n        prepareRefresh();\n        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n        prepareBeanFactory(beanFactory);\n        try {\n            postProcessBeanFactory(beanFactory);\n            invokeBeanFactoryPostProcessors(beanFactory);\n            registerBeanPostProcessors(beanFactory);\n            initMessageSource();\n            initApplicationEventMulticaster();\n            onRefresh();\n            registerListeners();\n            finishBeanFactoryInitialization(beanFactory);\n            finishRefresh();\n        }\n        catch (BeansException ex) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Exception encountered during context initialization - \" +\n                        \"cancelling refresh attempt: \" + ex);\n            }\n            destroyBeans();\n            cancelRefresh(ex);\n            throw ex;\n        }\n        finally {\n            resetCommonCaches();\n        }\n    }\n}\n~~~\n1. 首先对刷新进行准备，包括设置开始时间、设置激活状态、初始化 Context 环境中的占位符，这个动作根据子类的需求由子类来执行，然后验证是否缺失必要的 properties。\n2. 刷新并获得内部的 Bean Factory。\n3. 对 BeanFactory 进行准备工作，比如设置类加载器和后置处理器、配置不进行自动装配的类型、注册默认的环境 Bean。\n4. 为 Context 的子类提供后置处理 BeanFactory 的扩展能力。如果子类想在 Bean 定义加载完成后，开始初始化上下文之前做一些特殊逻辑，可以复写这个方法。\n5. 执行 Context 中注册的 Bean Factory 后缀处理器。这里有两种后置处理器，一种是可以注册 Bean 的后缀处理器，另一种是针对 BeanFactory 进行处理的后置处理器。执行的顺序是，先按优先级执行可注册 Bean 的处理器，在按优先级执行针对 BeanFactory的处理器。对 Spring Boot 来说，这一步会进行注解 Bean Definition 的解析。流程如图右侧所示，由 ConfigurationClassPostProcessor 触发、由 ClassPathBeanDefinitionScanner 解析并注册到 BeanFactory。\n6. 按优先级顺序在 BeanFactory 中注册  Bean的后缀处理器，Bean 后置处理器可以在 Bean 初始化前、后执行处理。\n7. 初始化消息源，消息源用来支持消息的国际化。\n8. 初始化应用事件广播器。事件广播器用来向 ApplicationListener 通知各种应用产生的事件，是一个标准的观察者模式。\n9. 是留给子类的扩展步骤，用来让特定的 Context 子类初始化其他的 Bean。\n10. 把实现了 ApplicationListener 的 Bean 注册到事件广播器，并对广播器中的早期未广播事件进行通知。\n11. 冻结所有 Bean 描述信息的修改，实例化非延迟加载的单例 Bean。\n12. 完成上下文的刷新工作，调用 LifecycleProcessor 的 onFresh() 方法以及发布 ContextRefreshedEvent 事件。\n13. 在 finally 中，执行第十三步，重置公共的缓存，比如 ReflectionUtils 中的缓存、 AnnotationUtils 中的缓存等等。\n\n## Bean生命周期\n1. 调用 Bean 的构造方法创建 Bean；\n2. 通过反射调用 setter 方法进行属性的依赖注入；\n3. 如果实现 BeanNameAware 接口的话，会设置 Bean 的 name；\n4. 如果实现了 BeanFactoryAware，会把 BeanFactory 设置给 Bean；\n5. 如果实现了 ApplicationContextAware，会给 Bean 设置 ApplictionContext；\n6. 如果实现了 BeanPostProcessor 接口，则执行前置处理方法；\n7. 实现了 InitializingBean 接口的话，执行 afterPropertiesSet 方法；\n8. 执行自定义的 init 方法；\n9. 执行 BeanPostProcessor 接口的后置处理方法；\n10. 在使用完 Bean 需要销毁时，会先执行 DisposableBean 接口的 destroy 方法，然后在执行自定义的 destroy 方法。\n\n# Spring Boot\n## SpringBoot启动流程\n~~~java\npublic ConfigurableApplicationContext run(String... args) {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start();\n    ConfigurableApplicationContext context = null;\n    Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();\n    configureHeadlessProperty();\n    SpringApplicationRunListeners listeners = getRunListeners(args);\n    listeners.starting();\n    try {\n        ApplicationArguments applicationArguments = new DefaultApplicationArguments(\n                args);\n        ConfigurableEnvironment environment = prepareEnvironment(listeners,\n                applicationArguments);\n        configureIgnoreBeanInfo(environment);\n        Banner printedBanner = printBanner(environment);\n        context = createApplicationContext();\n        exceptionReporters = getSpringFactoriesInstances(\n                SpringBootExceptionReporter.class,\n                new Class[] { ConfigurableApplicationContext.class }, context);\n        prepareContext(context, environment, listeners, applicationArguments,\n                printedBanner);\n        refreshContext(context);\n        afterRefresh(context, applicationArguments);\n        stopWatch.stop();\n        if (this.logStartupInfo) {\n            new StartupInfoLogger(this.mainApplicationClass)\n                    .logStarted(getApplicationLog(), stopWatch);\n        }\n        listeners.started(context);\n        callRunners(context, applicationArguments);\n    }\n    catch (Throwable ex) {\n        handleRunFailure(context, ex, exceptionReporters, listeners);\n        throw new IllegalStateException(ex);\n    }\n\n    try {\n        listeners.running(context);\n    }\n    catch (Throwable ex) {\n        handleRunFailure(context, ex, exceptionReporters, null);\n        throw new IllegalStateException(ex);\n    }\n    return context;\n}\n~~~\n1. 配置Environment。\n2. 准备 Context 上下文，包括执行 ApplicationContext 的后置处理、初始化 Initializer、通知Listener 处理 ContextPrepared 和 ContextLoaded 事件。\n3. 执行 refreshContext。\n\n## 配置文件\n* bootstrap\n* application\n\n## 注解\n* SpringBootApplication\n* SpringBootConfiguration\n* EnableAutoConfiguration\n* @Conditional\n\n## 模块\n* Starter\n* Actuator\n* DevTools\n* CLI\n\n# Spring Cloud\n\n# Spring Data\n\n# Spring Security","source":"_posts/20180727.md","raw":"---\ntitle: Spring\ncategory: 应用模块\n---\n\n# Spring Framework\n\n## Context初始化流程\n~~~java\npublic void refresh() throws BeansException, IllegalStateException {\n    synchronized (this.startupShutdownMonitor) {\n        prepareRefresh();\n        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n        prepareBeanFactory(beanFactory);\n        try {\n            postProcessBeanFactory(beanFactory);\n            invokeBeanFactoryPostProcessors(beanFactory);\n            registerBeanPostProcessors(beanFactory);\n            initMessageSource();\n            initApplicationEventMulticaster();\n            onRefresh();\n            registerListeners();\n            finishBeanFactoryInitialization(beanFactory);\n            finishRefresh();\n        }\n        catch (BeansException ex) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Exception encountered during context initialization - \" +\n                        \"cancelling refresh attempt: \" + ex);\n            }\n            destroyBeans();\n            cancelRefresh(ex);\n            throw ex;\n        }\n        finally {\n            resetCommonCaches();\n        }\n    }\n}\n~~~\n1. 首先对刷新进行准备，包括设置开始时间、设置激活状态、初始化 Context 环境中的占位符，这个动作根据子类的需求由子类来执行，然后验证是否缺失必要的 properties。\n2. 刷新并获得内部的 Bean Factory。\n3. 对 BeanFactory 进行准备工作，比如设置类加载器和后置处理器、配置不进行自动装配的类型、注册默认的环境 Bean。\n4. 为 Context 的子类提供后置处理 BeanFactory 的扩展能力。如果子类想在 Bean 定义加载完成后，开始初始化上下文之前做一些特殊逻辑，可以复写这个方法。\n5. 执行 Context 中注册的 Bean Factory 后缀处理器。这里有两种后置处理器，一种是可以注册 Bean 的后缀处理器，另一种是针对 BeanFactory 进行处理的后置处理器。执行的顺序是，先按优先级执行可注册 Bean 的处理器，在按优先级执行针对 BeanFactory的处理器。对 Spring Boot 来说，这一步会进行注解 Bean Definition 的解析。流程如图右侧所示，由 ConfigurationClassPostProcessor 触发、由 ClassPathBeanDefinitionScanner 解析并注册到 BeanFactory。\n6. 按优先级顺序在 BeanFactory 中注册  Bean的后缀处理器，Bean 后置处理器可以在 Bean 初始化前、后执行处理。\n7. 初始化消息源，消息源用来支持消息的国际化。\n8. 初始化应用事件广播器。事件广播器用来向 ApplicationListener 通知各种应用产生的事件，是一个标准的观察者模式。\n9. 是留给子类的扩展步骤，用来让特定的 Context 子类初始化其他的 Bean。\n10. 把实现了 ApplicationListener 的 Bean 注册到事件广播器，并对广播器中的早期未广播事件进行通知。\n11. 冻结所有 Bean 描述信息的修改，实例化非延迟加载的单例 Bean。\n12. 完成上下文的刷新工作，调用 LifecycleProcessor 的 onFresh() 方法以及发布 ContextRefreshedEvent 事件。\n13. 在 finally 中，执行第十三步，重置公共的缓存，比如 ReflectionUtils 中的缓存、 AnnotationUtils 中的缓存等等。\n\n## Bean生命周期\n1. 调用 Bean 的构造方法创建 Bean；\n2. 通过反射调用 setter 方法进行属性的依赖注入；\n3. 如果实现 BeanNameAware 接口的话，会设置 Bean 的 name；\n4. 如果实现了 BeanFactoryAware，会把 BeanFactory 设置给 Bean；\n5. 如果实现了 ApplicationContextAware，会给 Bean 设置 ApplictionContext；\n6. 如果实现了 BeanPostProcessor 接口，则执行前置处理方法；\n7. 实现了 InitializingBean 接口的话，执行 afterPropertiesSet 方法；\n8. 执行自定义的 init 方法；\n9. 执行 BeanPostProcessor 接口的后置处理方法；\n10. 在使用完 Bean 需要销毁时，会先执行 DisposableBean 接口的 destroy 方法，然后在执行自定义的 destroy 方法。\n\n# Spring Boot\n## SpringBoot启动流程\n~~~java\npublic ConfigurableApplicationContext run(String... args) {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start();\n    ConfigurableApplicationContext context = null;\n    Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();\n    configureHeadlessProperty();\n    SpringApplicationRunListeners listeners = getRunListeners(args);\n    listeners.starting();\n    try {\n        ApplicationArguments applicationArguments = new DefaultApplicationArguments(\n                args);\n        ConfigurableEnvironment environment = prepareEnvironment(listeners,\n                applicationArguments);\n        configureIgnoreBeanInfo(environment);\n        Banner printedBanner = printBanner(environment);\n        context = createApplicationContext();\n        exceptionReporters = getSpringFactoriesInstances(\n                SpringBootExceptionReporter.class,\n                new Class[] { ConfigurableApplicationContext.class }, context);\n        prepareContext(context, environment, listeners, applicationArguments,\n                printedBanner);\n        refreshContext(context);\n        afterRefresh(context, applicationArguments);\n        stopWatch.stop();\n        if (this.logStartupInfo) {\n            new StartupInfoLogger(this.mainApplicationClass)\n                    .logStarted(getApplicationLog(), stopWatch);\n        }\n        listeners.started(context);\n        callRunners(context, applicationArguments);\n    }\n    catch (Throwable ex) {\n        handleRunFailure(context, ex, exceptionReporters, listeners);\n        throw new IllegalStateException(ex);\n    }\n\n    try {\n        listeners.running(context);\n    }\n    catch (Throwable ex) {\n        handleRunFailure(context, ex, exceptionReporters, null);\n        throw new IllegalStateException(ex);\n    }\n    return context;\n}\n~~~\n1. 配置Environment。\n2. 准备 Context 上下文，包括执行 ApplicationContext 的后置处理、初始化 Initializer、通知Listener 处理 ContextPrepared 和 ContextLoaded 事件。\n3. 执行 refreshContext。\n\n## 配置文件\n* bootstrap\n* application\n\n## 注解\n* SpringBootApplication\n* SpringBootConfiguration\n* EnableAutoConfiguration\n* @Conditional\n\n## 模块\n* Starter\n* Actuator\n* DevTools\n* CLI\n\n# Spring Cloud\n\n# Spring Data\n\n# Spring Security","slug":"20180727","published":1,"date":"2021-07-29T02:57:29.338Z","updated":"2021-07-29T02:57:29.338Z","_id":"ckrnhewku000aeg0moljl7jh0","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Spring-Framework\"><a href=\"#Spring-Framework\" class=\"headerlink\" title=\"Spring Framework\"></a>Spring Framework</h1><h2 id=\"Context初始化流程\"><a href=\"#Context初始化流程\" class=\"headerlink\" title=\"Context初始化流程\"></a>Context初始化流程</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> BeansException, IllegalStateException </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.startupShutdownMonitor) &#123;</div><div class=\"line\">        prepareRefresh();</div><div class=\"line\">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</div><div class=\"line\">        prepareBeanFactory(beanFactory);</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            postProcessBeanFactory(beanFactory);</div><div class=\"line\">            invokeBeanFactoryPostProcessors(beanFactory);</div><div class=\"line\">            registerBeanPostProcessors(beanFactory);</div><div class=\"line\">            initMessageSource();</div><div class=\"line\">            initApplicationEventMulticaster();</div><div class=\"line\">            onRefresh();</div><div class=\"line\">            registerListeners();</div><div class=\"line\">            finishBeanFactoryInitialization(beanFactory);</div><div class=\"line\">            finishRefresh();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">catch</span> (BeansException ex) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (logger.isWarnEnabled()) &#123;</div><div class=\"line\">                logger.warn(<span class=\"string\">\"Exception encountered during context initialization - \"</span> +</div><div class=\"line\">                        <span class=\"string\">\"cancelling refresh attempt: \"</span> + ex);</div><div class=\"line\">            &#125;</div><div class=\"line\">            destroyBeans();</div><div class=\"line\">            cancelRefresh(ex);</div><div class=\"line\">            <span class=\"keyword\">throw</span> ex;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            resetCommonCaches();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>首先对刷新进行准备，包括设置开始时间、设置激活状态、初始化 Context 环境中的占位符，这个动作根据子类的需求由子类来执行，然后验证是否缺失必要的 properties。</li>\n<li>刷新并获得内部的 Bean Factory。</li>\n<li>对 BeanFactory 进行准备工作，比如设置类加载器和后置处理器、配置不进行自动装配的类型、注册默认的环境 Bean。</li>\n<li>为 Context 的子类提供后置处理 BeanFactory 的扩展能力。如果子类想在 Bean 定义加载完成后，开始初始化上下文之前做一些特殊逻辑，可以复写这个方法。</li>\n<li>执行 Context 中注册的 Bean Factory 后缀处理器。这里有两种后置处理器，一种是可以注册 Bean 的后缀处理器，另一种是针对 BeanFactory 进行处理的后置处理器。执行的顺序是，先按优先级执行可注册 Bean 的处理器，在按优先级执行针对 BeanFactory的处理器。对 Spring Boot 来说，这一步会进行注解 Bean Definition 的解析。流程如图右侧所示，由 ConfigurationClassPostProcessor 触发、由 ClassPathBeanDefinitionScanner 解析并注册到 BeanFactory。</li>\n<li>按优先级顺序在 BeanFactory 中注册  Bean的后缀处理器，Bean 后置处理器可以在 Bean 初始化前、后执行处理。</li>\n<li>初始化消息源，消息源用来支持消息的国际化。</li>\n<li>初始化应用事件广播器。事件广播器用来向 ApplicationListener 通知各种应用产生的事件，是一个标准的观察者模式。</li>\n<li>是留给子类的扩展步骤，用来让特定的 Context 子类初始化其他的 Bean。</li>\n<li>把实现了 ApplicationListener 的 Bean 注册到事件广播器，并对广播器中的早期未广播事件进行通知。</li>\n<li>冻结所有 Bean 描述信息的修改，实例化非延迟加载的单例 Bean。</li>\n<li>完成上下文的刷新工作，调用 LifecycleProcessor 的 onFresh() 方法以及发布 ContextRefreshedEvent 事件。</li>\n<li>在 finally 中，执行第十三步，重置公共的缓存，比如 ReflectionUtils 中的缓存、 AnnotationUtils 中的缓存等等。</li>\n</ol>\n<h2 id=\"Bean生命周期\"><a href=\"#Bean生命周期\" class=\"headerlink\" title=\"Bean生命周期\"></a>Bean生命周期</h2><ol>\n<li>调用 Bean 的构造方法创建 Bean；</li>\n<li>通过反射调用 setter 方法进行属性的依赖注入；</li>\n<li>如果实现 BeanNameAware 接口的话，会设置 Bean 的 name；</li>\n<li>如果实现了 BeanFactoryAware，会把 BeanFactory 设置给 Bean；</li>\n<li>如果实现了 ApplicationContextAware，会给 Bean 设置 ApplictionContext；</li>\n<li>如果实现了 BeanPostProcessor 接口，则执行前置处理方法；</li>\n<li>实现了 InitializingBean 接口的话，执行 afterPropertiesSet 方法；</li>\n<li>执行自定义的 init 方法；</li>\n<li>执行 BeanPostProcessor 接口的后置处理方法；</li>\n<li>在使用完 Bean 需要销毁时，会先执行 DisposableBean 接口的 destroy 方法，然后在执行自定义的 destroy 方法。</li>\n</ol>\n<h1 id=\"Spring-Boot\"><a href=\"#Spring-Boot\" class=\"headerlink\" title=\"Spring Boot\"></a>Spring Boot</h1><h2 id=\"SpringBoot启动流程\"><a href=\"#SpringBoot启动流程\" class=\"headerlink\" title=\"SpringBoot启动流程\"></a>SpringBoot启动流程</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(String... args)</span> </span>&#123;</div><div class=\"line\">    StopWatch stopWatch = <span class=\"keyword\">new</span> StopWatch();</div><div class=\"line\">    stopWatch.start();</div><div class=\"line\">    ConfigurableApplicationContext context = <span class=\"keyword\">null</span>;</div><div class=\"line\">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">    configureHeadlessProperty();</div><div class=\"line\">    SpringApplicationRunListeners listeners = getRunListeners(args);</div><div class=\"line\">    listeners.starting();</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        ApplicationArguments applicationArguments = <span class=\"keyword\">new</span> DefaultApplicationArguments(</div><div class=\"line\">                args);</div><div class=\"line\">        ConfigurableEnvironment environment = prepareEnvironment(listeners,</div><div class=\"line\">                applicationArguments);</div><div class=\"line\">        configureIgnoreBeanInfo(environment);</div><div class=\"line\">        Banner printedBanner = printBanner(environment);</div><div class=\"line\">        context = createApplicationContext();</div><div class=\"line\">        exceptionReporters = getSpringFactoriesInstances(</div><div class=\"line\">                SpringBootExceptionReporter.class,</div><div class=\"line\">                <span class=\"keyword\">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</div><div class=\"line\">        prepareContext(context, environment, listeners, applicationArguments,</div><div class=\"line\">                printedBanner);</div><div class=\"line\">        refreshContext(context);</div><div class=\"line\">        afterRefresh(context, applicationArguments);</div><div class=\"line\">        stopWatch.stop();</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</div><div class=\"line\">            <span class=\"keyword\">new</span> StartupInfoLogger(<span class=\"keyword\">this</span>.mainApplicationClass)</div><div class=\"line\">                    .logStarted(getApplicationLog(), stopWatch);</div><div class=\"line\">        &#125;</div><div class=\"line\">        listeners.started(context);</div><div class=\"line\">        callRunners(context, applicationArguments);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">        handleRunFailure(context, ex, exceptionReporters, listeners);</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        listeners.running(context);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">        handleRunFailure(context, ex, exceptionReporters, <span class=\"keyword\">null</span>);</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> context;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>配置Environment。</li>\n<li>准备 Context 上下文，包括执行 ApplicationContext 的后置处理、初始化 Initializer、通知Listener 处理 ContextPrepared 和 ContextLoaded 事件。</li>\n<li>执行 refreshContext。</li>\n</ol>\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><ul>\n<li>bootstrap</li>\n<li>application</li>\n</ul>\n<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><ul>\n<li>SpringBootApplication</li>\n<li>SpringBootConfiguration</li>\n<li>EnableAutoConfiguration</li>\n<li>@Conditional</li>\n</ul>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><ul>\n<li>Starter</li>\n<li>Actuator</li>\n<li>DevTools</li>\n<li>CLI</li>\n</ul>\n<h1 id=\"Spring-Cloud\"><a href=\"#Spring-Cloud\" class=\"headerlink\" title=\"Spring Cloud\"></a>Spring Cloud</h1><h1 id=\"Spring-Data\"><a href=\"#Spring-Data\" class=\"headerlink\" title=\"Spring Data\"></a>Spring Data</h1><h1 id=\"Spring-Security\"><a href=\"#Spring-Security\" class=\"headerlink\" title=\"Spring Security\"></a>Spring Security</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Spring-Framework\"><a href=\"#Spring-Framework\" class=\"headerlink\" title=\"Spring Framework\"></a>Spring Framework</h1><h2 id=\"Context初始化流程\"><a href=\"#Context初始化流程\" class=\"headerlink\" title=\"Context初始化流程\"></a>Context初始化流程</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> BeansException, IllegalStateException </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.startupShutdownMonitor) &#123;</div><div class=\"line\">        prepareRefresh();</div><div class=\"line\">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</div><div class=\"line\">        prepareBeanFactory(beanFactory);</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            postProcessBeanFactory(beanFactory);</div><div class=\"line\">            invokeBeanFactoryPostProcessors(beanFactory);</div><div class=\"line\">            registerBeanPostProcessors(beanFactory);</div><div class=\"line\">            initMessageSource();</div><div class=\"line\">            initApplicationEventMulticaster();</div><div class=\"line\">            onRefresh();</div><div class=\"line\">            registerListeners();</div><div class=\"line\">            finishBeanFactoryInitialization(beanFactory);</div><div class=\"line\">            finishRefresh();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">catch</span> (BeansException ex) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (logger.isWarnEnabled()) &#123;</div><div class=\"line\">                logger.warn(<span class=\"string\">\"Exception encountered during context initialization - \"</span> +</div><div class=\"line\">                        <span class=\"string\">\"cancelling refresh attempt: \"</span> + ex);</div><div class=\"line\">            &#125;</div><div class=\"line\">            destroyBeans();</div><div class=\"line\">            cancelRefresh(ex);</div><div class=\"line\">            <span class=\"keyword\">throw</span> ex;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            resetCommonCaches();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>首先对刷新进行准备，包括设置开始时间、设置激活状态、初始化 Context 环境中的占位符，这个动作根据子类的需求由子类来执行，然后验证是否缺失必要的 properties。</li>\n<li>刷新并获得内部的 Bean Factory。</li>\n<li>对 BeanFactory 进行准备工作，比如设置类加载器和后置处理器、配置不进行自动装配的类型、注册默认的环境 Bean。</li>\n<li>为 Context 的子类提供后置处理 BeanFactory 的扩展能力。如果子类想在 Bean 定义加载完成后，开始初始化上下文之前做一些特殊逻辑，可以复写这个方法。</li>\n<li>执行 Context 中注册的 Bean Factory 后缀处理器。这里有两种后置处理器，一种是可以注册 Bean 的后缀处理器，另一种是针对 BeanFactory 进行处理的后置处理器。执行的顺序是，先按优先级执行可注册 Bean 的处理器，在按优先级执行针对 BeanFactory的处理器。对 Spring Boot 来说，这一步会进行注解 Bean Definition 的解析。流程如图右侧所示，由 ConfigurationClassPostProcessor 触发、由 ClassPathBeanDefinitionScanner 解析并注册到 BeanFactory。</li>\n<li>按优先级顺序在 BeanFactory 中注册  Bean的后缀处理器，Bean 后置处理器可以在 Bean 初始化前、后执行处理。</li>\n<li>初始化消息源，消息源用来支持消息的国际化。</li>\n<li>初始化应用事件广播器。事件广播器用来向 ApplicationListener 通知各种应用产生的事件，是一个标准的观察者模式。</li>\n<li>是留给子类的扩展步骤，用来让特定的 Context 子类初始化其他的 Bean。</li>\n<li>把实现了 ApplicationListener 的 Bean 注册到事件广播器，并对广播器中的早期未广播事件进行通知。</li>\n<li>冻结所有 Bean 描述信息的修改，实例化非延迟加载的单例 Bean。</li>\n<li>完成上下文的刷新工作，调用 LifecycleProcessor 的 onFresh() 方法以及发布 ContextRefreshedEvent 事件。</li>\n<li>在 finally 中，执行第十三步，重置公共的缓存，比如 ReflectionUtils 中的缓存、 AnnotationUtils 中的缓存等等。</li>\n</ol>\n<h2 id=\"Bean生命周期\"><a href=\"#Bean生命周期\" class=\"headerlink\" title=\"Bean生命周期\"></a>Bean生命周期</h2><ol>\n<li>调用 Bean 的构造方法创建 Bean；</li>\n<li>通过反射调用 setter 方法进行属性的依赖注入；</li>\n<li>如果实现 BeanNameAware 接口的话，会设置 Bean 的 name；</li>\n<li>如果实现了 BeanFactoryAware，会把 BeanFactory 设置给 Bean；</li>\n<li>如果实现了 ApplicationContextAware，会给 Bean 设置 ApplictionContext；</li>\n<li>如果实现了 BeanPostProcessor 接口，则执行前置处理方法；</li>\n<li>实现了 InitializingBean 接口的话，执行 afterPropertiesSet 方法；</li>\n<li>执行自定义的 init 方法；</li>\n<li>执行 BeanPostProcessor 接口的后置处理方法；</li>\n<li>在使用完 Bean 需要销毁时，会先执行 DisposableBean 接口的 destroy 方法，然后在执行自定义的 destroy 方法。</li>\n</ol>\n<h1 id=\"Spring-Boot\"><a href=\"#Spring-Boot\" class=\"headerlink\" title=\"Spring Boot\"></a>Spring Boot</h1><h2 id=\"SpringBoot启动流程\"><a href=\"#SpringBoot启动流程\" class=\"headerlink\" title=\"SpringBoot启动流程\"></a>SpringBoot启动流程</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(String... args)</span> </span>&#123;</div><div class=\"line\">    StopWatch stopWatch = <span class=\"keyword\">new</span> StopWatch();</div><div class=\"line\">    stopWatch.start();</div><div class=\"line\">    ConfigurableApplicationContext context = <span class=\"keyword\">null</span>;</div><div class=\"line\">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">    configureHeadlessProperty();</div><div class=\"line\">    SpringApplicationRunListeners listeners = getRunListeners(args);</div><div class=\"line\">    listeners.starting();</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        ApplicationArguments applicationArguments = <span class=\"keyword\">new</span> DefaultApplicationArguments(</div><div class=\"line\">                args);</div><div class=\"line\">        ConfigurableEnvironment environment = prepareEnvironment(listeners,</div><div class=\"line\">                applicationArguments);</div><div class=\"line\">        configureIgnoreBeanInfo(environment);</div><div class=\"line\">        Banner printedBanner = printBanner(environment);</div><div class=\"line\">        context = createApplicationContext();</div><div class=\"line\">        exceptionReporters = getSpringFactoriesInstances(</div><div class=\"line\">                SpringBootExceptionReporter.class,</div><div class=\"line\">                <span class=\"keyword\">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</div><div class=\"line\">        prepareContext(context, environment, listeners, applicationArguments,</div><div class=\"line\">                printedBanner);</div><div class=\"line\">        refreshContext(context);</div><div class=\"line\">        afterRefresh(context, applicationArguments);</div><div class=\"line\">        stopWatch.stop();</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</div><div class=\"line\">            <span class=\"keyword\">new</span> StartupInfoLogger(<span class=\"keyword\">this</span>.mainApplicationClass)</div><div class=\"line\">                    .logStarted(getApplicationLog(), stopWatch);</div><div class=\"line\">        &#125;</div><div class=\"line\">        listeners.started(context);</div><div class=\"line\">        callRunners(context, applicationArguments);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">        handleRunFailure(context, ex, exceptionReporters, listeners);</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        listeners.running(context);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">        handleRunFailure(context, ex, exceptionReporters, <span class=\"keyword\">null</span>);</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> context;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>配置Environment。</li>\n<li>准备 Context 上下文，包括执行 ApplicationContext 的后置处理、初始化 Initializer、通知Listener 处理 ContextPrepared 和 ContextLoaded 事件。</li>\n<li>执行 refreshContext。</li>\n</ol>\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><ul>\n<li>bootstrap</li>\n<li>application</li>\n</ul>\n<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><ul>\n<li>SpringBootApplication</li>\n<li>SpringBootConfiguration</li>\n<li>EnableAutoConfiguration</li>\n<li>@Conditional</li>\n</ul>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><ul>\n<li>Starter</li>\n<li>Actuator</li>\n<li>DevTools</li>\n<li>CLI</li>\n</ul>\n<h1 id=\"Spring-Cloud\"><a href=\"#Spring-Cloud\" class=\"headerlink\" title=\"Spring Cloud\"></a>Spring Cloud</h1><h1 id=\"Spring-Data\"><a href=\"#Spring-Data\" class=\"headerlink\" title=\"Spring Data\"></a>Spring Data</h1><h1 id=\"Spring-Security\"><a href=\"#Spring-Security\" class=\"headerlink\" title=\"Spring Security\"></a>Spring Security</h1>"},{"title":"RPC","_content":"","source":"_posts/20180815.md","raw":"---\ntitle: RPC \ncategory: 应用模块\n---\n","slug":"20180815","published":1,"date":"2021-07-29T02:57:29.341Z","updated":"2021-07-29T02:57:29.341Z","_id":"ckrnhewkv000beg0mjdw5h9vz","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"MyBatis","_content":"\n## 处理流程\n\n1. 在执行 SQL 时，首先会从 SqlSessionFactory 中创建一个新的 SqlSession。\n2. SQL 语句是通过 SqlSession 中的 Executor 来执行，Executor 根据 SqlSession 传递的参数执行 query() 方法，然后创建一个 StatementHandler 对象，将必要的参数传递给 StatementHandler，由 StatementHandler 来完成对数据库的查询。\n3. StatementHandler 调用 ParameterHandler 的 setParameters 方法，把用户传递的参数转换成 JDBC Statement 所需要的参数， 调用原生 JDBC 来执行语句。\n4. 最后由 ResultSetHandler 的 handleResultSets 方法将 JDBC 返回的 ResultSet 结果集转换成对象集，并逐级返回结果，完成一次 SQL 语句执行。","source":"_posts/20180802.md","raw":"---\ntitle: MyBatis\ncategory: 应用模块\n---\n\n## 处理流程\n\n1. 在执行 SQL 时，首先会从 SqlSessionFactory 中创建一个新的 SqlSession。\n2. SQL 语句是通过 SqlSession 中的 Executor 来执行，Executor 根据 SqlSession 传递的参数执行 query() 方法，然后创建一个 StatementHandler 对象，将必要的参数传递给 StatementHandler，由 StatementHandler 来完成对数据库的查询。\n3. StatementHandler 调用 ParameterHandler 的 setParameters 方法，把用户传递的参数转换成 JDBC Statement 所需要的参数， 调用原生 JDBC 来执行语句。\n4. 最后由 ResultSetHandler 的 handleResultSets 方法将 JDBC 返回的 ResultSet 结果集转换成对象集，并逐级返回结果，完成一次 SQL 语句执行。","slug":"20180802","published":1,"date":"2021-07-29T02:57:29.339Z","updated":"2021-07-29T02:57:29.339Z","_id":"ckrnhewkw000ceg0mfie5wwtu","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"处理流程\"><a href=\"#处理流程\" class=\"headerlink\" title=\"处理流程\"></a>处理流程</h2><ol>\n<li>在执行 SQL 时，首先会从 SqlSessionFactory 中创建一个新的 SqlSession。</li>\n<li>SQL 语句是通过 SqlSession 中的 Executor 来执行，Executor 根据 SqlSession 传递的参数执行 query() 方法，然后创建一个 StatementHandler 对象，将必要的参数传递给 StatementHandler，由 StatementHandler 来完成对数据库的查询。</li>\n<li>StatementHandler 调用 ParameterHandler 的 setParameters 方法，把用户传递的参数转换成 JDBC Statement 所需要的参数， 调用原生 JDBC 来执行语句。</li>\n<li>最后由 ResultSetHandler 的 handleResultSets 方法将 JDBC 返回的 ResultSet 结果集转换成对象集，并逐级返回结果，完成一次 SQL 语句执行。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"处理流程\"><a href=\"#处理流程\" class=\"headerlink\" title=\"处理流程\"></a>处理流程</h2><ol>\n<li>在执行 SQL 时，首先会从 SqlSessionFactory 中创建一个新的 SqlSession。</li>\n<li>SQL 语句是通过 SqlSession 中的 Executor 来执行，Executor 根据 SqlSession 传递的参数执行 query() 方法，然后创建一个 StatementHandler 对象，将必要的参数传递给 StatementHandler，由 StatementHandler 来完成对数据库的查询。</li>\n<li>StatementHandler 调用 ParameterHandler 的 setParameters 方法，把用户传递的参数转换成 JDBC Statement 所需要的参数， 调用原生 JDBC 来执行语句。</li>\n<li>最后由 ResultSetHandler 的 handleResultSets 方法将 JDBC 返回的 ResultSet 结果集转换成对象集，并逐级返回结果，完成一次 SQL 语句执行。</li>\n</ol>\n"},{"title":"消息队列","_content":"\n## 应用场景\n解耦合、削峰填谷、异步\n\n## 消息协议\nAMQP\nJMS\n\n## 常用队列\n* ActiveMQ: 单机吞吐量万级，有较低概率丢失消息\n* RabbitMQ: Erlang开发，单机吞吐万级\n* RocketMQ: 阿里开源，单机吞吐量10W级\n* Kafka: Scala开发, 单机吞吐量10W级，发布订阅模式","source":"_posts/20181010.md","raw":"---\ntitle: 消息队列\ncategory: 应用模块\ntag: 消息队列\n---\n\n## 应用场景\n解耦合、削峰填谷、异步\n\n## 消息协议\nAMQP\nJMS\n\n## 常用队列\n* ActiveMQ: 单机吞吐量万级，有较低概率丢失消息\n* RabbitMQ: Erlang开发，单机吞吐万级\n* RocketMQ: 阿里开源，单机吞吐量10W级\n* Kafka: Scala开发, 单机吞吐量10W级，发布订阅模式","slug":"20181010","published":1,"date":"2021-07-29T02:57:29.344Z","updated":"2021-07-29T02:57:29.344Z","_id":"ckrnhewkx000deg0m7mo5jy12","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>解耦合、削峰填谷、异步</p>\n<h2 id=\"消息协议\"><a href=\"#消息协议\" class=\"headerlink\" title=\"消息协议\"></a>消息协议</h2><p>AMQP<br>JMS</p>\n<h2 id=\"常用队列\"><a href=\"#常用队列\" class=\"headerlink\" title=\"常用队列\"></a>常用队列</h2><ul>\n<li>ActiveMQ: 单机吞吐量万级，有较低概率丢失消息</li>\n<li>RabbitMQ: Erlang开发，单机吞吐万级</li>\n<li>RocketMQ: 阿里开源，单机吞吐量10W级</li>\n<li>Kafka: Scala开发, 单机吞吐量10W级，发布订阅模式</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>解耦合、削峰填谷、异步</p>\n<h2 id=\"消息协议\"><a href=\"#消息协议\" class=\"headerlink\" title=\"消息协议\"></a>消息协议</h2><p>AMQP<br>JMS</p>\n<h2 id=\"常用队列\"><a href=\"#常用队列\" class=\"headerlink\" title=\"常用队列\"></a>常用队列</h2><ul>\n<li>ActiveMQ: 单机吞吐量万级，有较低概率丢失消息</li>\n<li>RabbitMQ: Erlang开发，单机吞吐万级</li>\n<li>RocketMQ: 阿里开源，单机吞吐量10W级</li>\n<li>Kafka: Scala开发, 单机吞吐量10W级，发布订阅模式</li>\n</ul>\n"},{"title":"缓存","_content":"\n缓存是高并发场景下提高热点数据访问性能的一个有效手段，使用内存来保存数据。\n<!--more-->\n\n## 类型\n* 本地缓存\n    * Caffeine\n* 分布式缓存\n    * Redis\n    * Memcache\n* 多级缓存：本地缓存 + 分布式缓存\n实际业务中一般采用多级缓存，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中。\n\n## 淘汰策略\n由于成本和内存限制，当存储的数据超过缓存容量时，需要对缓存的数据进行剔除。\n* FIFO：淘汰最早数据。\n* LRU：剔除最近最少使用。\n* LFU：剔除最近使用频率最低的数据几种策略。\n\n## 缓存常见问题\n### 缓存更新方式：数据变更、缓存时效性\n在使用缓存时就该考虑的问题，在数据源（可能是 DB，也可能是远程服务）发生变更时需要对缓存进行更新。\nDB：在更新完 DB 后就直接更新缓存\n远程服务：可能无法及时主动感知数据变更，这种情况下一般会选择对缓存数据设置失效期，也就是数据不一致的最大容忍时间。这种场景下，可以选择失效更新，key 不存在或失效时先请求数据源获取最新数据，然后再次缓存，并更新失效期。但这样做有个问题，如果依赖的远程服务在更新时出现异常，则会导致数据不可用。改进的办法是异步更新，就是当失效时先不清除数据，继续使用旧的数据，然后由异步线程去执行更新任务。这样就避免了失效瞬间的空窗期。另外还有一种纯异步更新方式，定时对数据进行分批更新。实际使用时可以根据业务场景选择更新方式。\n\n### 缓存不一致：同步更新失败、异步更新\n只要使用缓存，就要考虑如何面对这个问题。缓存不一致产生的原因一般是主动更新失败，例如更新 DB 后，更新 Redis 因为网络原因请求超时；或者是异步更新失败导致。\n服务对耗时不是特别敏感：可以增加重试。\n服务对耗时不是特别敏感：可以通过异步补偿任务来处理失败的更新。\n短期的数据不一致不会影响业务：那么只要下次更新时可以成功，能保证最终一致性就可以。\n\n### 缓存穿透：恶意攻击\n产生这个问题的原因可能是外部的恶意攻击，例如，对用户信息进行了缓存，但恶意攻击者使用不存在的用户id频繁请求接口，导致查询缓存不命中，然后穿透 DB 查询依然不命中。这时会有大量请求穿透缓存访问到 DB。\n* 对不存在的数据，在缓存中保存一个空对象进行标记，防止相同 ID 再次访问 DB。不过有时这个方法并不能很好解决问题，可能导致缓存中存储大量无用数据。\n* 使用 BloomFilter 过滤器，BloomFilter 的特点是存在性检测，如果 BloomFilter 中不存在，那么数据一定不存在；如果 BloomFilter 中存在，实际数据也有可能会不存在。非常适合解决这类的问题。\n\n### 缓存击穿：热点key失效\n某个热点数据失效时，大量针对这个数据的请求会穿透到数据源。\n* 可以使用互斥锁更新，保证同一个进程中针对同一个数据不会并发请求到 DB，减小 DB 压力。\n* 使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新。\n* 针对多个热点 key 同时失效的问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效。\n\n### 缓存雪崩：缓存挂掉\n产生的原因是缓存挂掉，这时所有的请求都会穿透到 DB。\n* 使用快速失败的熔断策略，减少 DB 瞬间压力。\n* 使用主从模式和集群模式来尽量保证缓存服务的高可用。","source":"_posts/20180916.md","raw":"---\ntitle: 缓存\ncategory: 应用模块\ntag: 缓存\n---\n\n缓存是高并发场景下提高热点数据访问性能的一个有效手段，使用内存来保存数据。\n<!--more-->\n\n## 类型\n* 本地缓存\n    * Caffeine\n* 分布式缓存\n    * Redis\n    * Memcache\n* 多级缓存：本地缓存 + 分布式缓存\n实际业务中一般采用多级缓存，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中。\n\n## 淘汰策略\n由于成本和内存限制，当存储的数据超过缓存容量时，需要对缓存的数据进行剔除。\n* FIFO：淘汰最早数据。\n* LRU：剔除最近最少使用。\n* LFU：剔除最近使用频率最低的数据几种策略。\n\n## 缓存常见问题\n### 缓存更新方式：数据变更、缓存时效性\n在使用缓存时就该考虑的问题，在数据源（可能是 DB，也可能是远程服务）发生变更时需要对缓存进行更新。\nDB：在更新完 DB 后就直接更新缓存\n远程服务：可能无法及时主动感知数据变更，这种情况下一般会选择对缓存数据设置失效期，也就是数据不一致的最大容忍时间。这种场景下，可以选择失效更新，key 不存在或失效时先请求数据源获取最新数据，然后再次缓存，并更新失效期。但这样做有个问题，如果依赖的远程服务在更新时出现异常，则会导致数据不可用。改进的办法是异步更新，就是当失效时先不清除数据，继续使用旧的数据，然后由异步线程去执行更新任务。这样就避免了失效瞬间的空窗期。另外还有一种纯异步更新方式，定时对数据进行分批更新。实际使用时可以根据业务场景选择更新方式。\n\n### 缓存不一致：同步更新失败、异步更新\n只要使用缓存，就要考虑如何面对这个问题。缓存不一致产生的原因一般是主动更新失败，例如更新 DB 后，更新 Redis 因为网络原因请求超时；或者是异步更新失败导致。\n服务对耗时不是特别敏感：可以增加重试。\n服务对耗时不是特别敏感：可以通过异步补偿任务来处理失败的更新。\n短期的数据不一致不会影响业务：那么只要下次更新时可以成功，能保证最终一致性就可以。\n\n### 缓存穿透：恶意攻击\n产生这个问题的原因可能是外部的恶意攻击，例如，对用户信息进行了缓存，但恶意攻击者使用不存在的用户id频繁请求接口，导致查询缓存不命中，然后穿透 DB 查询依然不命中。这时会有大量请求穿透缓存访问到 DB。\n* 对不存在的数据，在缓存中保存一个空对象进行标记，防止相同 ID 再次访问 DB。不过有时这个方法并不能很好解决问题，可能导致缓存中存储大量无用数据。\n* 使用 BloomFilter 过滤器，BloomFilter 的特点是存在性检测，如果 BloomFilter 中不存在，那么数据一定不存在；如果 BloomFilter 中存在，实际数据也有可能会不存在。非常适合解决这类的问题。\n\n### 缓存击穿：热点key失效\n某个热点数据失效时，大量针对这个数据的请求会穿透到数据源。\n* 可以使用互斥锁更新，保证同一个进程中针对同一个数据不会并发请求到 DB，减小 DB 压力。\n* 使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新。\n* 针对多个热点 key 同时失效的问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效。\n\n### 缓存雪崩：缓存挂掉\n产生的原因是缓存挂掉，这时所有的请求都会穿透到 DB。\n* 使用快速失败的熔断策略，减少 DB 瞬间压力。\n* 使用主从模式和集群模式来尽量保证缓存服务的高可用。","slug":"20180916","published":1,"date":"2021-07-29T02:57:29.342Z","updated":"2021-07-29T07:21:54.716Z","_id":"ckrnhewky000eeg0mgbk9hxmv","comments":1,"layout":"post","photos":[],"link":"","content":"<p>缓存是高并发场景下提高热点数据访问性能的一个有效手段，使用内存来保存数据。<br><a id=\"more\"></a></p>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><ul>\n<li>本地缓存<ul>\n<li>Caffeine</li>\n</ul>\n</li>\n<li>分布式缓存<ul>\n<li>Redis</li>\n<li>Memcache</li>\n</ul>\n</li>\n<li>多级缓存：本地缓存 + 分布式缓存<br>实际业务中一般采用多级缓存，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中。</li>\n</ul>\n<h2 id=\"淘汰策略\"><a href=\"#淘汰策略\" class=\"headerlink\" title=\"淘汰策略\"></a>淘汰策略</h2><p>由于成本和内存限制，当存储的数据超过缓存容量时，需要对缓存的数据进行剔除。</p>\n<ul>\n<li>FIFO：淘汰最早数据。</li>\n<li>LRU：剔除最近最少使用。</li>\n<li>LFU：剔除最近使用频率最低的数据几种策略。</li>\n</ul>\n<h2 id=\"缓存常见问题\"><a href=\"#缓存常见问题\" class=\"headerlink\" title=\"缓存常见问题\"></a>缓存常见问题</h2><h3 id=\"缓存更新方式：数据变更、缓存时效性\"><a href=\"#缓存更新方式：数据变更、缓存时效性\" class=\"headerlink\" title=\"缓存更新方式：数据变更、缓存时效性\"></a>缓存更新方式：数据变更、缓存时效性</h3><p>在使用缓存时就该考虑的问题，在数据源（可能是 DB，也可能是远程服务）发生变更时需要对缓存进行更新。<br>DB：在更新完 DB 后就直接更新缓存<br>远程服务：可能无法及时主动感知数据变更，这种情况下一般会选择对缓存数据设置失效期，也就是数据不一致的最大容忍时间。这种场景下，可以选择失效更新，key 不存在或失效时先请求数据源获取最新数据，然后再次缓存，并更新失效期。但这样做有个问题，如果依赖的远程服务在更新时出现异常，则会导致数据不可用。改进的办法是异步更新，就是当失效时先不清除数据，继续使用旧的数据，然后由异步线程去执行更新任务。这样就避免了失效瞬间的空窗期。另外还有一种纯异步更新方式，定时对数据进行分批更新。实际使用时可以根据业务场景选择更新方式。</p>\n<h3 id=\"缓存不一致：同步更新失败、异步更新\"><a href=\"#缓存不一致：同步更新失败、异步更新\" class=\"headerlink\" title=\"缓存不一致：同步更新失败、异步更新\"></a>缓存不一致：同步更新失败、异步更新</h3><p>只要使用缓存，就要考虑如何面对这个问题。缓存不一致产生的原因一般是主动更新失败，例如更新 DB 后，更新 Redis 因为网络原因请求超时；或者是异步更新失败导致。<br>服务对耗时不是特别敏感：可以增加重试。<br>服务对耗时不是特别敏感：可以通过异步补偿任务来处理失败的更新。<br>短期的数据不一致不会影响业务：那么只要下次更新时可以成功，能保证最终一致性就可以。</p>\n<h3 id=\"缓存穿透：恶意攻击\"><a href=\"#缓存穿透：恶意攻击\" class=\"headerlink\" title=\"缓存穿透：恶意攻击\"></a>缓存穿透：恶意攻击</h3><p>产生这个问题的原因可能是外部的恶意攻击，例如，对用户信息进行了缓存，但恶意攻击者使用不存在的用户id频繁请求接口，导致查询缓存不命中，然后穿透 DB 查询依然不命中。这时会有大量请求穿透缓存访问到 DB。</p>\n<ul>\n<li>对不存在的数据，在缓存中保存一个空对象进行标记，防止相同 ID 再次访问 DB。不过有时这个方法并不能很好解决问题，可能导致缓存中存储大量无用数据。</li>\n<li>使用 BloomFilter 过滤器，BloomFilter 的特点是存在性检测，如果 BloomFilter 中不存在，那么数据一定不存在；如果 BloomFilter 中存在，实际数据也有可能会不存在。非常适合解决这类的问题。</li>\n</ul>\n<h3 id=\"缓存击穿：热点key失效\"><a href=\"#缓存击穿：热点key失效\" class=\"headerlink\" title=\"缓存击穿：热点key失效\"></a>缓存击穿：热点key失效</h3><p>某个热点数据失效时，大量针对这个数据的请求会穿透到数据源。</p>\n<ul>\n<li>可以使用互斥锁更新，保证同一个进程中针对同一个数据不会并发请求到 DB，减小 DB 压力。</li>\n<li>使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新。</li>\n<li>针对多个热点 key 同时失效的问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效。</li>\n</ul>\n<h3 id=\"缓存雪崩：缓存挂掉\"><a href=\"#缓存雪崩：缓存挂掉\" class=\"headerlink\" title=\"缓存雪崩：缓存挂掉\"></a>缓存雪崩：缓存挂掉</h3><p>产生的原因是缓存挂掉，这时所有的请求都会穿透到 DB。</p>\n<ul>\n<li>使用快速失败的熔断策略，减少 DB 瞬间压力。</li>\n<li>使用主从模式和集群模式来尽量保证缓存服务的高可用。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>缓存是高并发场景下提高热点数据访问性能的一个有效手段，使用内存来保存数据。<br>","more":"</p>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><ul>\n<li>本地缓存<ul>\n<li>Caffeine</li>\n</ul>\n</li>\n<li>分布式缓存<ul>\n<li>Redis</li>\n<li>Memcache</li>\n</ul>\n</li>\n<li>多级缓存：本地缓存 + 分布式缓存<br>实际业务中一般采用多级缓存，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中。</li>\n</ul>\n<h2 id=\"淘汰策略\"><a href=\"#淘汰策略\" class=\"headerlink\" title=\"淘汰策略\"></a>淘汰策略</h2><p>由于成本和内存限制，当存储的数据超过缓存容量时，需要对缓存的数据进行剔除。</p>\n<ul>\n<li>FIFO：淘汰最早数据。</li>\n<li>LRU：剔除最近最少使用。</li>\n<li>LFU：剔除最近使用频率最低的数据几种策略。</li>\n</ul>\n<h2 id=\"缓存常见问题\"><a href=\"#缓存常见问题\" class=\"headerlink\" title=\"缓存常见问题\"></a>缓存常见问题</h2><h3 id=\"缓存更新方式：数据变更、缓存时效性\"><a href=\"#缓存更新方式：数据变更、缓存时效性\" class=\"headerlink\" title=\"缓存更新方式：数据变更、缓存时效性\"></a>缓存更新方式：数据变更、缓存时效性</h3><p>在使用缓存时就该考虑的问题，在数据源（可能是 DB，也可能是远程服务）发生变更时需要对缓存进行更新。<br>DB：在更新完 DB 后就直接更新缓存<br>远程服务：可能无法及时主动感知数据变更，这种情况下一般会选择对缓存数据设置失效期，也就是数据不一致的最大容忍时间。这种场景下，可以选择失效更新，key 不存在或失效时先请求数据源获取最新数据，然后再次缓存，并更新失效期。但这样做有个问题，如果依赖的远程服务在更新时出现异常，则会导致数据不可用。改进的办法是异步更新，就是当失效时先不清除数据，继续使用旧的数据，然后由异步线程去执行更新任务。这样就避免了失效瞬间的空窗期。另外还有一种纯异步更新方式，定时对数据进行分批更新。实际使用时可以根据业务场景选择更新方式。</p>\n<h3 id=\"缓存不一致：同步更新失败、异步更新\"><a href=\"#缓存不一致：同步更新失败、异步更新\" class=\"headerlink\" title=\"缓存不一致：同步更新失败、异步更新\"></a>缓存不一致：同步更新失败、异步更新</h3><p>只要使用缓存，就要考虑如何面对这个问题。缓存不一致产生的原因一般是主动更新失败，例如更新 DB 后，更新 Redis 因为网络原因请求超时；或者是异步更新失败导致。<br>服务对耗时不是特别敏感：可以增加重试。<br>服务对耗时不是特别敏感：可以通过异步补偿任务来处理失败的更新。<br>短期的数据不一致不会影响业务：那么只要下次更新时可以成功，能保证最终一致性就可以。</p>\n<h3 id=\"缓存穿透：恶意攻击\"><a href=\"#缓存穿透：恶意攻击\" class=\"headerlink\" title=\"缓存穿透：恶意攻击\"></a>缓存穿透：恶意攻击</h3><p>产生这个问题的原因可能是外部的恶意攻击，例如，对用户信息进行了缓存，但恶意攻击者使用不存在的用户id频繁请求接口，导致查询缓存不命中，然后穿透 DB 查询依然不命中。这时会有大量请求穿透缓存访问到 DB。</p>\n<ul>\n<li>对不存在的数据，在缓存中保存一个空对象进行标记，防止相同 ID 再次访问 DB。不过有时这个方法并不能很好解决问题，可能导致缓存中存储大量无用数据。</li>\n<li>使用 BloomFilter 过滤器，BloomFilter 的特点是存在性检测，如果 BloomFilter 中不存在，那么数据一定不存在；如果 BloomFilter 中存在，实际数据也有可能会不存在。非常适合解决这类的问题。</li>\n</ul>\n<h3 id=\"缓存击穿：热点key失效\"><a href=\"#缓存击穿：热点key失效\" class=\"headerlink\" title=\"缓存击穿：热点key失效\"></a>缓存击穿：热点key失效</h3><p>某个热点数据失效时，大量针对这个数据的请求会穿透到数据源。</p>\n<ul>\n<li>可以使用互斥锁更新，保证同一个进程中针对同一个数据不会并发请求到 DB，减小 DB 压力。</li>\n<li>使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新。</li>\n<li>针对多个热点 key 同时失效的问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效。</li>\n</ul>\n<h3 id=\"缓存雪崩：缓存挂掉\"><a href=\"#缓存雪崩：缓存挂掉\" class=\"headerlink\" title=\"缓存雪崩：缓存挂掉\"></a>缓存雪崩：缓存挂掉</h3><p>产生的原因是缓存挂掉，这时所有的请求都会穿透到 DB。</p>\n<ul>\n<li>使用快速失败的熔断策略，减少 DB 瞬间压力。</li>\n<li>使用主从模式和集群模式来尽量保证缓存服务的高可用。</li>\n</ul>"},{"title":"数据库","_content":"\n## 常用数据库\n\n* 关系型数据库\n    * MySQL\n    * Oracle\n    * PostgreSQL(PGSQL)\n    * MariaDB\n* NoSQL\n    * MongoDB\n    * HBase\n    * Cassandra\n    * Pika\n* NewSQL\n    * TiDB\n    * OceanBase\n    \n## 事务\n### 事务特性\nA(Atomicity)C(Consistency)I(Isolation)D(Durability)\n\n### 隔离级别\n* 读未提交\n* 读已提交\n* 可重复读\n* 串行化\n\n### 事务分类\n* 扁平化事务\n* 带保存点的扁平化事务\n* 链事务\n* 嵌套事务\n* 分布式事务\n    * XA协议方案：2PC、3PC\n    * TCC方案\n    * 消息一致性方案\n    * GTS方案","source":"_posts/20181023.md","raw":"---\ntitle: 数据库\ncategory: 应用模块\ntag: 数据库\n---\n\n## 常用数据库\n\n* 关系型数据库\n    * MySQL\n    * Oracle\n    * PostgreSQL(PGSQL)\n    * MariaDB\n* NoSQL\n    * MongoDB\n    * HBase\n    * Cassandra\n    * Pika\n* NewSQL\n    * TiDB\n    * OceanBase\n    \n## 事务\n### 事务特性\nA(Atomicity)C(Consistency)I(Isolation)D(Durability)\n\n### 隔离级别\n* 读未提交\n* 读已提交\n* 可重复读\n* 串行化\n\n### 事务分类\n* 扁平化事务\n* 带保存点的扁平化事务\n* 链事务\n* 嵌套事务\n* 分布式事务\n    * XA协议方案：2PC、3PC\n    * TCC方案\n    * 消息一致性方案\n    * GTS方案","slug":"20181023","published":1,"date":"2021-07-29T02:57:29.345Z","updated":"2021-07-29T02:57:29.345Z","_id":"ckrnhewkz000feg0mbgurr2u4","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"常用数据库\"><a href=\"#常用数据库\" class=\"headerlink\" title=\"常用数据库\"></a>常用数据库</h2><ul>\n<li>关系型数据库<ul>\n<li>MySQL</li>\n<li>Oracle</li>\n<li>PostgreSQL(PGSQL)</li>\n<li>MariaDB</li>\n</ul>\n</li>\n<li>NoSQL<ul>\n<li>MongoDB</li>\n<li>HBase</li>\n<li>Cassandra</li>\n<li>Pika</li>\n</ul>\n</li>\n<li>NewSQL<ul>\n<li>TiDB</li>\n<li>OceanBase</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"事务特性\"><a href=\"#事务特性\" class=\"headerlink\" title=\"事务特性\"></a>事务特性</h3><p>A(Atomicity)C(Consistency)I(Isolation)D(Durability)</p>\n<h3 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h3><ul>\n<li>读未提交</li>\n<li>读已提交</li>\n<li>可重复读</li>\n<li>串行化</li>\n</ul>\n<h3 id=\"事务分类\"><a href=\"#事务分类\" class=\"headerlink\" title=\"事务分类\"></a>事务分类</h3><ul>\n<li>扁平化事务</li>\n<li>带保存点的扁平化事务</li>\n<li>链事务</li>\n<li>嵌套事务</li>\n<li>分布式事务<ul>\n<li>XA协议方案：2PC、3PC</li>\n<li>TCC方案</li>\n<li>消息一致性方案</li>\n<li>GTS方案</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"常用数据库\"><a href=\"#常用数据库\" class=\"headerlink\" title=\"常用数据库\"></a>常用数据库</h2><ul>\n<li>关系型数据库<ul>\n<li>MySQL</li>\n<li>Oracle</li>\n<li>PostgreSQL(PGSQL)</li>\n<li>MariaDB</li>\n</ul>\n</li>\n<li>NoSQL<ul>\n<li>MongoDB</li>\n<li>HBase</li>\n<li>Cassandra</li>\n<li>Pika</li>\n</ul>\n</li>\n<li>NewSQL<ul>\n<li>TiDB</li>\n<li>OceanBase</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"事务特性\"><a href=\"#事务特性\" class=\"headerlink\" title=\"事务特性\"></a>事务特性</h3><p>A(Atomicity)C(Consistency)I(Isolation)D(Durability)</p>\n<h3 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h3><ul>\n<li>读未提交</li>\n<li>读已提交</li>\n<li>可重复读</li>\n<li>串行化</li>\n</ul>\n<h3 id=\"事务分类\"><a href=\"#事务分类\" class=\"headerlink\" title=\"事务分类\"></a>事务分类</h3><ul>\n<li>扁平化事务</li>\n<li>带保存点的扁平化事务</li>\n<li>链事务</li>\n<li>嵌套事务</li>\n<li>分布式事务<ul>\n<li>XA协议方案：2PC、3PC</li>\n<li>TCC方案</li>\n<li>消息一致性方案</li>\n<li>GTS方案</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Kafka","_content":"\n## 生产消息\n生产者根据规则选择一个Partition写入\n* 轮询策略（默认规则）\n* 指定Partition\n* 指定key来根据Hash值选择Partition\n\n消息发送方式\n* 同步：默认方式\n* 异步：允许批量\n* oneway：不需要返回结果\n\n## 消费消息\n* Consumer按照Group来消费消息，topic中的每一条消息可以被多个Consumer Group消费；\n* 每个Partition在一个Group中只能由一个Consumer消费，通过Group Coordinator来管理Consumer实际负责消费哪个Partiton，默认支持轮询和Range分配。\n* Kafka在zk中保存了每个Topic中每个Partition在不同Group的消费偏移量offset。\n**注意**：分区数量一般要大于或等于消费者（同一Group）数量。否则，有的消费者会消费不到数据\n  \n## 经验\n### 集成Spring Kafka\n~~~\n<dependency>\n    <groupId>org.springframework.kafka</groupId>\n    <artifactId>spring-kafka</artifactId>\n</dependency>\n~~~\n生产：使用 KafkaTemplte 生产消息，多个Kafka实例需生产消息时配置不同的KafkaTemplate\n消费：单条消费时直接使用 @KafkaListener 注解即可，批量消费需先配置containerFactory\n\n### 生产者\nack\n* -1或all\n* 0\n* 1\n\n### 消费者\n提高消费速度\n* 增加Consumer个数\n* 增加处理线程：定义一个线程池，Poll数据，将数据提交到线程池中，再次Poll数据。\n\n### 可视化\n[可视化工具下载地址](https://www.kafkatool.com/download.html)\n\n## 参考文章\n[CKafka常用参数配置指南](https://cloud.tencent.com/document/product/597/30203)\n[发布者最佳实践](https://help.aliyun.com/document_detail/68165.html?spm=a2c4g.11186623.6.761.1615358bafQjos)\n[订阅者最佳实践](https://help.aliyun.com/document_detail/68166.html?spm=a2c4g.11186623.6.762.4297203abkfLec)\n","source":"_posts/20181112.md","raw":"---\ntitle: Kafka\ncategory: 应用模块\ntag: 消息队列\n---\n\n## 生产消息\n生产者根据规则选择一个Partition写入\n* 轮询策略（默认规则）\n* 指定Partition\n* 指定key来根据Hash值选择Partition\n\n消息发送方式\n* 同步：默认方式\n* 异步：允许批量\n* oneway：不需要返回结果\n\n## 消费消息\n* Consumer按照Group来消费消息，topic中的每一条消息可以被多个Consumer Group消费；\n* 每个Partition在一个Group中只能由一个Consumer消费，通过Group Coordinator来管理Consumer实际负责消费哪个Partiton，默认支持轮询和Range分配。\n* Kafka在zk中保存了每个Topic中每个Partition在不同Group的消费偏移量offset。\n**注意**：分区数量一般要大于或等于消费者（同一Group）数量。否则，有的消费者会消费不到数据\n  \n## 经验\n### 集成Spring Kafka\n~~~\n<dependency>\n    <groupId>org.springframework.kafka</groupId>\n    <artifactId>spring-kafka</artifactId>\n</dependency>\n~~~\n生产：使用 KafkaTemplte 生产消息，多个Kafka实例需生产消息时配置不同的KafkaTemplate\n消费：单条消费时直接使用 @KafkaListener 注解即可，批量消费需先配置containerFactory\n\n### 生产者\nack\n* -1或all\n* 0\n* 1\n\n### 消费者\n提高消费速度\n* 增加Consumer个数\n* 增加处理线程：定义一个线程池，Poll数据，将数据提交到线程池中，再次Poll数据。\n\n### 可视化\n[可视化工具下载地址](https://www.kafkatool.com/download.html)\n\n## 参考文章\n[CKafka常用参数配置指南](https://cloud.tencent.com/document/product/597/30203)\n[发布者最佳实践](https://help.aliyun.com/document_detail/68165.html?spm=a2c4g.11186623.6.761.1615358bafQjos)\n[订阅者最佳实践](https://help.aliyun.com/document_detail/68166.html?spm=a2c4g.11186623.6.762.4297203abkfLec)\n","slug":"20181112","published":1,"date":"2021-07-29T02:57:29.348Z","updated":"2021-07-29T02:57:29.349Z","_id":"ckrnhewl0000geg0m99n8jz6w","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"生产消息\"><a href=\"#生产消息\" class=\"headerlink\" title=\"生产消息\"></a>生产消息</h2><p>生产者根据规则选择一个Partition写入</p>\n<ul>\n<li>轮询策略（默认规则）</li>\n<li>指定Partition</li>\n<li>指定key来根据Hash值选择Partition</li>\n</ul>\n<p>消息发送方式</p>\n<ul>\n<li>同步：默认方式</li>\n<li>异步：允许批量</li>\n<li>oneway：不需要返回结果</li>\n</ul>\n<h2 id=\"消费消息\"><a href=\"#消费消息\" class=\"headerlink\" title=\"消费消息\"></a>消费消息</h2><ul>\n<li>Consumer按照Group来消费消息，topic中的每一条消息可以被多个Consumer Group消费；</li>\n<li>每个Partition在一个Group中只能由一个Consumer消费，通过Group Coordinator来管理Consumer实际负责消费哪个Partiton，默认支持轮询和Range分配。</li>\n<li>Kafka在zk中保存了每个Topic中每个Partition在不同Group的消费偏移量offset。<br><strong>注意</strong>：分区数量一般要大于或等于消费者（同一Group）数量。否则，有的消费者会消费不到数据</li>\n</ul>\n<h2 id=\"经验\"><a href=\"#经验\" class=\"headerlink\" title=\"经验\"></a>经验</h2><h3 id=\"集成Spring-Kafka\"><a href=\"#集成Spring-Kafka\" class=\"headerlink\" title=\"集成Spring Kafka\"></a>集成Spring Kafka</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure>\n<p>生产：使用 KafkaTemplte 生产消息，多个Kafka实例需生产消息时配置不同的KafkaTemplate<br>消费：单条消费时直接使用 @KafkaListener 注解即可，批量消费需先配置containerFactory</p>\n<h3 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><p>ack</p>\n<ul>\n<li>-1或all</li>\n<li>0</li>\n<li>1</li>\n</ul>\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><p>提高消费速度</p>\n<ul>\n<li>增加Consumer个数</li>\n<li>增加处理线程：定义一个线程池，Poll数据，将数据提交到线程池中，再次Poll数据。</li>\n</ul>\n<h3 id=\"可视化\"><a href=\"#可视化\" class=\"headerlink\" title=\"可视化\"></a>可视化</h3><p><a href=\"https://www.kafkatool.com/download.html\" target=\"_blank\" rel=\"external\">可视化工具下载地址</a></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://cloud.tencent.com/document/product/597/30203\" target=\"_blank\" rel=\"external\">CKafka常用参数配置指南</a><br><a href=\"https://help.aliyun.com/document_detail/68165.html?spm=a2c4g.11186623.6.761.1615358bafQjos\" target=\"_blank\" rel=\"external\">发布者最佳实践</a><br><a href=\"https://help.aliyun.com/document_detail/68166.html?spm=a2c4g.11186623.6.762.4297203abkfLec\" target=\"_blank\" rel=\"external\">订阅者最佳实践</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"生产消息\"><a href=\"#生产消息\" class=\"headerlink\" title=\"生产消息\"></a>生产消息</h2><p>生产者根据规则选择一个Partition写入</p>\n<ul>\n<li>轮询策略（默认规则）</li>\n<li>指定Partition</li>\n<li>指定key来根据Hash值选择Partition</li>\n</ul>\n<p>消息发送方式</p>\n<ul>\n<li>同步：默认方式</li>\n<li>异步：允许批量</li>\n<li>oneway：不需要返回结果</li>\n</ul>\n<h2 id=\"消费消息\"><a href=\"#消费消息\" class=\"headerlink\" title=\"消费消息\"></a>消费消息</h2><ul>\n<li>Consumer按照Group来消费消息，topic中的每一条消息可以被多个Consumer Group消费；</li>\n<li>每个Partition在一个Group中只能由一个Consumer消费，通过Group Coordinator来管理Consumer实际负责消费哪个Partiton，默认支持轮询和Range分配。</li>\n<li>Kafka在zk中保存了每个Topic中每个Partition在不同Group的消费偏移量offset。<br><strong>注意</strong>：分区数量一般要大于或等于消费者（同一Group）数量。否则，有的消费者会消费不到数据</li>\n</ul>\n<h2 id=\"经验\"><a href=\"#经验\" class=\"headerlink\" title=\"经验\"></a>经验</h2><h3 id=\"集成Spring-Kafka\"><a href=\"#集成Spring-Kafka\" class=\"headerlink\" title=\"集成Spring Kafka\"></a>集成Spring Kafka</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure>\n<p>生产：使用 KafkaTemplte 生产消息，多个Kafka实例需生产消息时配置不同的KafkaTemplate<br>消费：单条消费时直接使用 @KafkaListener 注解即可，批量消费需先配置containerFactory</p>\n<h3 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><p>ack</p>\n<ul>\n<li>-1或all</li>\n<li>0</li>\n<li>1</li>\n</ul>\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><p>提高消费速度</p>\n<ul>\n<li>增加Consumer个数</li>\n<li>增加处理线程：定义一个线程池，Poll数据，将数据提交到线程池中，再次Poll数据。</li>\n</ul>\n<h3 id=\"可视化\"><a href=\"#可视化\" class=\"headerlink\" title=\"可视化\"></a>可视化</h3><p><a href=\"https://www.kafkatool.com/download.html\" target=\"_blank\" rel=\"external\">可视化工具下载地址</a></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://cloud.tencent.com/document/product/597/30203\" target=\"_blank\" rel=\"external\">CKafka常用参数配置指南</a><br><a href=\"https://help.aliyun.com/document_detail/68165.html?spm=a2c4g.11186623.6.761.1615358bafQjos\" target=\"_blank\" rel=\"external\">发布者最佳实践</a><br><a href=\"https://help.aliyun.com/document_detail/68166.html?spm=a2c4g.11186623.6.762.4297203abkfLec\" target=\"_blank\" rel=\"external\">订阅者最佳实践</a></p>\n"},{"title":"Redis","_content":"\n采用单线程模式处理请求，支持持久化，支持多种数据格式，能够提供高可用服务。\n<!--more-->\n\n## 数据结构\n![img](http://s0.lgstatic.com/i/image2/M01/8A/CA/CgoB5l14rXWAdWuJAABsOwtDCh0241.png)\n在 Redis 中，所有的对象都被封装成了 redisObject，如图中浅绿的模块。redisObject 包括了对象的类型，就是 Redis 支持的 string、hash、list、set 和 sorted set 5种类型。另外 redisObject 还包括了具体对象的存储方式。\n### string\n最常使用的类型，底层使用 SDS(Simple Dynamic String，类似于 Java 中的 ArrayList，可以通过预分配冗余空间的方式来减少内存的频繁分配。) 来存储。\n\n### list\nZipList 压缩列表：存储在一段连续的内存上，存储效率高，但是它不利于修改操作，适用于数据较少的情况。\nLinkedList 双链表：在插入节点上复杂度很低，但它的内存开销很大，每个节点的地址不连续，容易产生内存碎片。\nQuickList ：结合了前两者的优点本身是一个双向无环链表，它的每一个节点都是一个 ZipList。\n\n### hash\nZipList ：当 Hash 表中所有的 key 和 value 字符串长度都小于 64 字节且键值对数量小于 512 个时，使用压缩表来节省空间。\nHashTable ：超过时，转为使用 hashtable。\n\n### set\nIntSet ：当集合中元素小于 512 且所有的数据都是数值类型时，才会使用 IntSet。\nHashTable ：否则会使用 HashTable。\n\n### sorted set\nZipList ：有序集合的编码转换条件与 hash 和 list 有些不同，当有序集合中元素数量小于 128 个并且所有元素长度都小于 64 字节时会使用 ZipList。\nSkipList ：否则会转换成 SkipList。\n\n**注意**：Redis 的内存分配是使用 jemalloc 进行分配。jemalloc 将内存空间划分为小、大、巨大三个范围，并在范围中划分了小的内存块，当存储数据时，选择大小最合适的内存块进行分配，有利于减小内存碎片。\n\n## 高可用\n\n### 主从同步\n读写分离\n\n### Cluster 集群\n横向扩展\nRedis Cluster 使用分片机制，在内部分为 16384 个 slot 插槽，分布在所有 master 节点上，每个 master 节点负责一部分 slot。数据操作时按 key 做 CRC16 来计算在哪个 slot，由哪个 master 进行处理。数据的冗余是通过 slave 节点来保障。\n\n### Sentinel 哨兵\n通过 Sentinel 哨兵来监控 Redis 主服务器的状态。当主挂掉时，在从节点中根据一定策略选出新主，并调整其他从 SlaveOf 到新主。\n选主策略：\n* slave 的 priority 设置的越低，优先级越高；\n* 同等情况下，slave 复制的数据越多优先级越高；\n* 相同的条件下 RunId 越小越容易被选中。\nsentinel 也会进行多实例部署，sentinel 之间通过 Raft 协议来保证自身的高可用。\n\n## 持久化\nRDB：把内存中的数据集以快照形式写入磁盘，实际操作是通过 fork 子进程执行，采用二进制压缩存储。适合用来做灾备。\nAOF：以文本日志的形式记录 Redis 处理的每一个写入或删除操作。AOF 要大于 RDB，AOF 在运行效率上往往会慢于 RDB。\n\n## 功能\n### Bitmap\n位图是支持按 bit 位来存储信息，可以用来实现 BloomFilter。\n\n### HyperLogLog\n提供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV。\n\n### Geospatial\n可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。这三个其实也可以算作一种数据结构。\n\n### pub/sub\n订阅发布功能，可以用作简单的消息队列。\n\n### Pipeline\n以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。\n\n### Lua脚本\n支持提交 Lua 脚本来执行一系列的功能。\n\n### 事务\nRedis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。","source":"_posts/20181111.md","raw":"---\ntitle: Redis\ncategory: 应用模块\ntag: 缓存\n---\n\n采用单线程模式处理请求，支持持久化，支持多种数据格式，能够提供高可用服务。\n<!--more-->\n\n## 数据结构\n![img](http://s0.lgstatic.com/i/image2/M01/8A/CA/CgoB5l14rXWAdWuJAABsOwtDCh0241.png)\n在 Redis 中，所有的对象都被封装成了 redisObject，如图中浅绿的模块。redisObject 包括了对象的类型，就是 Redis 支持的 string、hash、list、set 和 sorted set 5种类型。另外 redisObject 还包括了具体对象的存储方式。\n### string\n最常使用的类型，底层使用 SDS(Simple Dynamic String，类似于 Java 中的 ArrayList，可以通过预分配冗余空间的方式来减少内存的频繁分配。) 来存储。\n\n### list\nZipList 压缩列表：存储在一段连续的内存上，存储效率高，但是它不利于修改操作，适用于数据较少的情况。\nLinkedList 双链表：在插入节点上复杂度很低，但它的内存开销很大，每个节点的地址不连续，容易产生内存碎片。\nQuickList ：结合了前两者的优点本身是一个双向无环链表，它的每一个节点都是一个 ZipList。\n\n### hash\nZipList ：当 Hash 表中所有的 key 和 value 字符串长度都小于 64 字节且键值对数量小于 512 个时，使用压缩表来节省空间。\nHashTable ：超过时，转为使用 hashtable。\n\n### set\nIntSet ：当集合中元素小于 512 且所有的数据都是数值类型时，才会使用 IntSet。\nHashTable ：否则会使用 HashTable。\n\n### sorted set\nZipList ：有序集合的编码转换条件与 hash 和 list 有些不同，当有序集合中元素数量小于 128 个并且所有元素长度都小于 64 字节时会使用 ZipList。\nSkipList ：否则会转换成 SkipList。\n\n**注意**：Redis 的内存分配是使用 jemalloc 进行分配。jemalloc 将内存空间划分为小、大、巨大三个范围，并在范围中划分了小的内存块，当存储数据时，选择大小最合适的内存块进行分配，有利于减小内存碎片。\n\n## 高可用\n\n### 主从同步\n读写分离\n\n### Cluster 集群\n横向扩展\nRedis Cluster 使用分片机制，在内部分为 16384 个 slot 插槽，分布在所有 master 节点上，每个 master 节点负责一部分 slot。数据操作时按 key 做 CRC16 来计算在哪个 slot，由哪个 master 进行处理。数据的冗余是通过 slave 节点来保障。\n\n### Sentinel 哨兵\n通过 Sentinel 哨兵来监控 Redis 主服务器的状态。当主挂掉时，在从节点中根据一定策略选出新主，并调整其他从 SlaveOf 到新主。\n选主策略：\n* slave 的 priority 设置的越低，优先级越高；\n* 同等情况下，slave 复制的数据越多优先级越高；\n* 相同的条件下 RunId 越小越容易被选中。\nsentinel 也会进行多实例部署，sentinel 之间通过 Raft 协议来保证自身的高可用。\n\n## 持久化\nRDB：把内存中的数据集以快照形式写入磁盘，实际操作是通过 fork 子进程执行，采用二进制压缩存储。适合用来做灾备。\nAOF：以文本日志的形式记录 Redis 处理的每一个写入或删除操作。AOF 要大于 RDB，AOF 在运行效率上往往会慢于 RDB。\n\n## 功能\n### Bitmap\n位图是支持按 bit 位来存储信息，可以用来实现 BloomFilter。\n\n### HyperLogLog\n提供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV。\n\n### Geospatial\n可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。这三个其实也可以算作一种数据结构。\n\n### pub/sub\n订阅发布功能，可以用作简单的消息队列。\n\n### Pipeline\n以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。\n\n### Lua脚本\n支持提交 Lua 脚本来执行一系列的功能。\n\n### 事务\nRedis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。","slug":"20181111","published":1,"date":"2021-07-29T02:57:29.346Z","updated":"2021-07-29T08:04:31.079Z","_id":"ckrnhewl0000heg0mena1cb43","comments":1,"layout":"post","photos":[],"link":"","content":"<p>采用单线程模式处理请求，支持持久化，支持多种数据格式，能够提供高可用服务。<br><a id=\"more\"></a></p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p><img src=\"http://s0.lgstatic.com/i/image2/M01/8A/CA/CgoB5l14rXWAdWuJAABsOwtDCh0241.png\" alt=\"img\"><br>在 Redis 中，所有的对象都被封装成了 redisObject，如图中浅绿的模块。redisObject 包括了对象的类型，就是 Redis 支持的 string、hash、list、set 和 sorted set 5种类型。另外 redisObject 还包括了具体对象的存储方式。</p>\n<h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><p>最常使用的类型，底层使用 SDS(Simple Dynamic String，类似于 Java 中的 ArrayList，可以通过预分配冗余空间的方式来减少内存的频繁分配。) 来存储。</p>\n<h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><p>ZipList 压缩列表：存储在一段连续的内存上，存储效率高，但是它不利于修改操作，适用于数据较少的情况。<br>LinkedList 双链表：在插入节点上复杂度很低，但它的内存开销很大，每个节点的地址不连续，容易产生内存碎片。<br>QuickList ：结合了前两者的优点本身是一个双向无环链表，它的每一个节点都是一个 ZipList。</p>\n<h3 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h3><p>ZipList ：当 Hash 表中所有的 key 和 value 字符串长度都小于 64 字节且键值对数量小于 512 个时，使用压缩表来节省空间。<br>HashTable ：超过时，转为使用 hashtable。</p>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p>IntSet ：当集合中元素小于 512 且所有的数据都是数值类型时，才会使用 IntSet。<br>HashTable ：否则会使用 HashTable。</p>\n<h3 id=\"sorted-set\"><a href=\"#sorted-set\" class=\"headerlink\" title=\"sorted set\"></a>sorted set</h3><p>ZipList ：有序集合的编码转换条件与 hash 和 list 有些不同，当有序集合中元素数量小于 128 个并且所有元素长度都小于 64 字节时会使用 ZipList。<br>SkipList ：否则会转换成 SkipList。</p>\n<p><strong>注意</strong>：Redis 的内存分配是使用 jemalloc 进行分配。jemalloc 将内存空间划分为小、大、巨大三个范围，并在范围中划分了小的内存块，当存储数据时，选择大小最合适的内存块进行分配，有利于减小内存碎片。</p>\n<h2 id=\"高可用\"><a href=\"#高可用\" class=\"headerlink\" title=\"高可用\"></a>高可用</h2><h3 id=\"主从同步\"><a href=\"#主从同步\" class=\"headerlink\" title=\"主从同步\"></a>主从同步</h3><p>读写分离</p>\n<h3 id=\"Cluster-集群\"><a href=\"#Cluster-集群\" class=\"headerlink\" title=\"Cluster 集群\"></a>Cluster 集群</h3><p>横向扩展<br>Redis Cluster 使用分片机制，在内部分为 16384 个 slot 插槽，分布在所有 master 节点上，每个 master 节点负责一部分 slot。数据操作时按 key 做 CRC16 来计算在哪个 slot，由哪个 master 进行处理。数据的冗余是通过 slave 节点来保障。</p>\n<h3 id=\"Sentinel-哨兵\"><a href=\"#Sentinel-哨兵\" class=\"headerlink\" title=\"Sentinel 哨兵\"></a>Sentinel 哨兵</h3><p>通过 Sentinel 哨兵来监控 Redis 主服务器的状态。当主挂掉时，在从节点中根据一定策略选出新主，并调整其他从 SlaveOf 到新主。<br>选主策略：</p>\n<ul>\n<li>slave 的 priority 设置的越低，优先级越高；</li>\n<li>同等情况下，slave 复制的数据越多优先级越高；</li>\n<li>相同的条件下 RunId 越小越容易被选中。<br>sentinel 也会进行多实例部署，sentinel 之间通过 Raft 协议来保证自身的高可用。</li>\n</ul>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>RDB：把内存中的数据集以快照形式写入磁盘，实际操作是通过 fork 子进程执行，采用二进制压缩存储。适合用来做灾备。<br>AOF：以文本日志的形式记录 Redis 处理的每一个写入或删除操作。AOF 要大于 RDB，AOF 在运行效率上往往会慢于 RDB。</p>\n<h2 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h2><h3 id=\"Bitmap\"><a href=\"#Bitmap\" class=\"headerlink\" title=\"Bitmap\"></a>Bitmap</h3><p>位图是支持按 bit 位来存储信息，可以用来实现 BloomFilter。</p>\n<h3 id=\"HyperLogLog\"><a href=\"#HyperLogLog\" class=\"headerlink\" title=\"HyperLogLog\"></a>HyperLogLog</h3><p>提供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV。</p>\n<h3 id=\"Geospatial\"><a href=\"#Geospatial\" class=\"headerlink\" title=\"Geospatial\"></a>Geospatial</h3><p>可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。这三个其实也可以算作一种数据结构。</p>\n<h3 id=\"pub-sub\"><a href=\"#pub-sub\" class=\"headerlink\" title=\"pub/sub\"></a>pub/sub</h3><p>订阅发布功能，可以用作简单的消息队列。</p>\n<h3 id=\"Pipeline\"><a href=\"#Pipeline\" class=\"headerlink\" title=\"Pipeline\"></a>Pipeline</h3><p>以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。</p>\n<h3 id=\"Lua脚本\"><a href=\"#Lua脚本\" class=\"headerlink\" title=\"Lua脚本\"></a>Lua脚本</h3><p>支持提交 Lua 脚本来执行一系列的功能。</p>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。</p>\n","site":{"data":{}},"excerpt":"<p>采用单线程模式处理请求，支持持久化，支持多种数据格式，能够提供高可用服务。<br>","more":"</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p><img src=\"http://s0.lgstatic.com/i/image2/M01/8A/CA/CgoB5l14rXWAdWuJAABsOwtDCh0241.png\" alt=\"img\"><br>在 Redis 中，所有的对象都被封装成了 redisObject，如图中浅绿的模块。redisObject 包括了对象的类型，就是 Redis 支持的 string、hash、list、set 和 sorted set 5种类型。另外 redisObject 还包括了具体对象的存储方式。</p>\n<h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><p>最常使用的类型，底层使用 SDS(Simple Dynamic String，类似于 Java 中的 ArrayList，可以通过预分配冗余空间的方式来减少内存的频繁分配。) 来存储。</p>\n<h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><p>ZipList 压缩列表：存储在一段连续的内存上，存储效率高，但是它不利于修改操作，适用于数据较少的情况。<br>LinkedList 双链表：在插入节点上复杂度很低，但它的内存开销很大，每个节点的地址不连续，容易产生内存碎片。<br>QuickList ：结合了前两者的优点本身是一个双向无环链表，它的每一个节点都是一个 ZipList。</p>\n<h3 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h3><p>ZipList ：当 Hash 表中所有的 key 和 value 字符串长度都小于 64 字节且键值对数量小于 512 个时，使用压缩表来节省空间。<br>HashTable ：超过时，转为使用 hashtable。</p>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p>IntSet ：当集合中元素小于 512 且所有的数据都是数值类型时，才会使用 IntSet。<br>HashTable ：否则会使用 HashTable。</p>\n<h3 id=\"sorted-set\"><a href=\"#sorted-set\" class=\"headerlink\" title=\"sorted set\"></a>sorted set</h3><p>ZipList ：有序集合的编码转换条件与 hash 和 list 有些不同，当有序集合中元素数量小于 128 个并且所有元素长度都小于 64 字节时会使用 ZipList。<br>SkipList ：否则会转换成 SkipList。</p>\n<p><strong>注意</strong>：Redis 的内存分配是使用 jemalloc 进行分配。jemalloc 将内存空间划分为小、大、巨大三个范围，并在范围中划分了小的内存块，当存储数据时，选择大小最合适的内存块进行分配，有利于减小内存碎片。</p>\n<h2 id=\"高可用\"><a href=\"#高可用\" class=\"headerlink\" title=\"高可用\"></a>高可用</h2><h3 id=\"主从同步\"><a href=\"#主从同步\" class=\"headerlink\" title=\"主从同步\"></a>主从同步</h3><p>读写分离</p>\n<h3 id=\"Cluster-集群\"><a href=\"#Cluster-集群\" class=\"headerlink\" title=\"Cluster 集群\"></a>Cluster 集群</h3><p>横向扩展<br>Redis Cluster 使用分片机制，在内部分为 16384 个 slot 插槽，分布在所有 master 节点上，每个 master 节点负责一部分 slot。数据操作时按 key 做 CRC16 来计算在哪个 slot，由哪个 master 进行处理。数据的冗余是通过 slave 节点来保障。</p>\n<h3 id=\"Sentinel-哨兵\"><a href=\"#Sentinel-哨兵\" class=\"headerlink\" title=\"Sentinel 哨兵\"></a>Sentinel 哨兵</h3><p>通过 Sentinel 哨兵来监控 Redis 主服务器的状态。当主挂掉时，在从节点中根据一定策略选出新主，并调整其他从 SlaveOf 到新主。<br>选主策略：</p>\n<ul>\n<li>slave 的 priority 设置的越低，优先级越高；</li>\n<li>同等情况下，slave 复制的数据越多优先级越高；</li>\n<li>相同的条件下 RunId 越小越容易被选中。<br>sentinel 也会进行多实例部署，sentinel 之间通过 Raft 协议来保证自身的高可用。</li>\n</ul>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>RDB：把内存中的数据集以快照形式写入磁盘，实际操作是通过 fork 子进程执行，采用二进制压缩存储。适合用来做灾备。<br>AOF：以文本日志的形式记录 Redis 处理的每一个写入或删除操作。AOF 要大于 RDB，AOF 在运行效率上往往会慢于 RDB。</p>\n<h2 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h2><h3 id=\"Bitmap\"><a href=\"#Bitmap\" class=\"headerlink\" title=\"Bitmap\"></a>Bitmap</h3><p>位图是支持按 bit 位来存储信息，可以用来实现 BloomFilter。</p>\n<h3 id=\"HyperLogLog\"><a href=\"#HyperLogLog\" class=\"headerlink\" title=\"HyperLogLog\"></a>HyperLogLog</h3><p>提供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV。</p>\n<h3 id=\"Geospatial\"><a href=\"#Geospatial\" class=\"headerlink\" title=\"Geospatial\"></a>Geospatial</h3><p>可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。这三个其实也可以算作一种数据结构。</p>\n<h3 id=\"pub-sub\"><a href=\"#pub-sub\" class=\"headerlink\" title=\"pub/sub\"></a>pub/sub</h3><p>订阅发布功能，可以用作简单的消息队列。</p>\n<h3 id=\"Pipeline\"><a href=\"#Pipeline\" class=\"headerlink\" title=\"Pipeline\"></a>Pipeline</h3><p>以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。</p>\n<h3 id=\"Lua脚本\"><a href=\"#Lua脚本\" class=\"headerlink\" title=\"Lua脚本\"></a>Lua脚本</h3><p>支持提交 Lua 脚本来执行一系列的功能。</p>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。</p>"},{"title":"MySQL","_content":"\n## 调优\n![img](http://s0.lgstatic.com/i/image2/M01/8A/CF/CgoB5l14tcCAW4TEAAA4gPziGLI076.png)\n这四个纬度从优化的成本角度来讲，从左到右优化成本逐渐升高；从优化效果角度来看，从右到左优化的效果更高。\n\n### 表结构及索引优化\n* 在设计表结构时，考虑数据库的水平与垂直扩展能力，提前规划好未来1年的数据量、读写量的增长，规划好分库分表方案。比如设计用户信息表，预计 1 年后用户数据 10亿 条，写 QPS 约 5000，读 QPS 30000，可以设计按 UID 纬度进行散列，分为 4 个库每个库 32 张表，单表数据量控制在 KW 级别。\n* 为字段选择合适的数据类型，在保留扩展能力的前提下，优先选用较小的数据结构。例如保存年龄的字段，要使用 TINYINT 而不要使用 INT。\n* 控制表的列数。\n* 如果查询时需要对多张表进行关联查询，可以设计一些冗余字段提高效率。\n* 要擅用索引，比如为经常作为查询条件的字段创建索引、创建联合索引时要根据最左原则考虑索引的复用能力，不要重复创建索引；要为保证数据不能重复的字段创建唯一索引等等。不过要注意索引对插入、更新等写操作是有代价的，不要滥用索引，比如像性别这样唯一很差的字段就不适合建立索引。\n* 列字段尽量设置为 not null。MySQL 难以对使用 null 的列进行查询优化，允许 null 会使索引、索引统计和值更加复杂，允许 null 值的列需要更多的存储空间，还需要 MySQL 内部进行特殊处理。\n\n### SQL语句优化\n* 要找到最需要优化的 SQL 语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询 MySQL 的慢查询日志来发现需要进行优化的 SQL 语句。\n* 利用 MySQL 提供的分析工具。例如使用 Explain 来分析语句的执行计划，看看是否使用了索引，使用了哪个索引，扫描了多少记录，是否使用文件排序等等。或者利用 Profile 命令来分析某个语句执行过程中各个分步的耗时。\n* 要注意使用查询语句是要避免使用 SELECT *，而是应该指定具体需要获取的字段。原因一是可以避免查询出不需要使用的字段，二是可以避免查询列字段的元信息。\n* 尽量使用 prepared statements，一个是它性能更好，另一个是可以防止 SQL 注入。\n* 尽量使用索引扫描来进行排序，也就是尽量在有索引的字段上进行排序操作。\n\n## 索引\n索引可以大幅增加数据库的查询的性能，但是索引也是有代价的，首先需要额外的磁盘空间来保存索引；其次，对于插入、更新、删除等操作由于更新索引会增加额外的开销，因此索引比较适合用在读多写少的场景。\n### 分类\n* 聚簇索引\n* 非聚簇索引\n* 唯一索引：索引列中的值必须是唯一的，但是允许出现空值。\n* 主键索引：一种特殊的唯一索引，但是它不允许出现空值。\n* 普通索引：唯一索引不同，它允许索引列中存在相同的值。\n* 联合索引：由多个列共同组成的索引，需遵循最左原则，就是 where 查询条件中的字段必须与索引字段从左到右进行匹配。\n* 全文索引：全文索引只能在 CHAR、VARCHAR、TEXT 类型字段上使用，底层使用倒排索引实现。\n\n### 实现\nB-Tree：适合用作 > 或 < 这样的范围查询，是 MySQL 中最常使用的一种索引实现。\nR-Tree：用于处理多维数据的数据结构，可以对地理数据进行空间索引。不过实际业务场景中使用的比较少。\nHash：散列表索引，效率高于 B-Tree，但是不支持范围查找和排序等功能。实际使用的也比较少。\nFullText：全文索引，是一种记录关键字与对应文档关系的倒排索引。\n\n## 存储引擎\n* MyISAM：是 MySQL 官方提供的存储引擎，其特点是支持全文索引，查询效率比较高，缺点是不支持事务、使用**表级锁**。\n* InnoDB：5.5版本后默认引擎。特点是支持 ACID 事务、支持外键、支持**行级锁**提高了并发效率。\n* TokuDB：是第三方开发的开源存储引擎，有非常快的写速度，支持数据的压缩存储、可以在线添加索引而不影响读写操作。但是因为压缩的原因，TokuDB 非常适合访问频率不高的数据或历史数据归档，不适合大量读取的场景。\n\n## 锁\n* 表锁：开销小，加锁快，不会出现死锁；但是锁的粒度大，发生锁冲突的概率高，并发访问效率比较低。\n* 行级锁：开销大，加锁慢，有可能会出现死锁，不过因为锁定粒度最小，发生锁冲突的概率低，并发访问效率比较高\n* 共享锁：读锁，其他事务可以读，但不能写。MySQL 可以通过 lock in share mode 语句显示使用共享锁。\n* 排他锁：写锁，其他事务不能读取，也不能写。对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会自动给涉及的数据集加排他锁，或者使用 select for update 显示使用排他锁。\n\n## 经验","source":"_posts/20181113.md","raw":"---\ntitle: MySQL\ncategory: 应用模块\ntag: 数据库\n---\n\n## 调优\n![img](http://s0.lgstatic.com/i/image2/M01/8A/CF/CgoB5l14tcCAW4TEAAA4gPziGLI076.png)\n这四个纬度从优化的成本角度来讲，从左到右优化成本逐渐升高；从优化效果角度来看，从右到左优化的效果更高。\n\n### 表结构及索引优化\n* 在设计表结构时，考虑数据库的水平与垂直扩展能力，提前规划好未来1年的数据量、读写量的增长，规划好分库分表方案。比如设计用户信息表，预计 1 年后用户数据 10亿 条，写 QPS 约 5000，读 QPS 30000，可以设计按 UID 纬度进行散列，分为 4 个库每个库 32 张表，单表数据量控制在 KW 级别。\n* 为字段选择合适的数据类型，在保留扩展能力的前提下，优先选用较小的数据结构。例如保存年龄的字段，要使用 TINYINT 而不要使用 INT。\n* 控制表的列数。\n* 如果查询时需要对多张表进行关联查询，可以设计一些冗余字段提高效率。\n* 要擅用索引，比如为经常作为查询条件的字段创建索引、创建联合索引时要根据最左原则考虑索引的复用能力，不要重复创建索引；要为保证数据不能重复的字段创建唯一索引等等。不过要注意索引对插入、更新等写操作是有代价的，不要滥用索引，比如像性别这样唯一很差的字段就不适合建立索引。\n* 列字段尽量设置为 not null。MySQL 难以对使用 null 的列进行查询优化，允许 null 会使索引、索引统计和值更加复杂，允许 null 值的列需要更多的存储空间，还需要 MySQL 内部进行特殊处理。\n\n### SQL语句优化\n* 要找到最需要优化的 SQL 语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询 MySQL 的慢查询日志来发现需要进行优化的 SQL 语句。\n* 利用 MySQL 提供的分析工具。例如使用 Explain 来分析语句的执行计划，看看是否使用了索引，使用了哪个索引，扫描了多少记录，是否使用文件排序等等。或者利用 Profile 命令来分析某个语句执行过程中各个分步的耗时。\n* 要注意使用查询语句是要避免使用 SELECT *，而是应该指定具体需要获取的字段。原因一是可以避免查询出不需要使用的字段，二是可以避免查询列字段的元信息。\n* 尽量使用 prepared statements，一个是它性能更好，另一个是可以防止 SQL 注入。\n* 尽量使用索引扫描来进行排序，也就是尽量在有索引的字段上进行排序操作。\n\n## 索引\n索引可以大幅增加数据库的查询的性能，但是索引也是有代价的，首先需要额外的磁盘空间来保存索引；其次，对于插入、更新、删除等操作由于更新索引会增加额外的开销，因此索引比较适合用在读多写少的场景。\n### 分类\n* 聚簇索引\n* 非聚簇索引\n* 唯一索引：索引列中的值必须是唯一的，但是允许出现空值。\n* 主键索引：一种特殊的唯一索引，但是它不允许出现空值。\n* 普通索引：唯一索引不同，它允许索引列中存在相同的值。\n* 联合索引：由多个列共同组成的索引，需遵循最左原则，就是 where 查询条件中的字段必须与索引字段从左到右进行匹配。\n* 全文索引：全文索引只能在 CHAR、VARCHAR、TEXT 类型字段上使用，底层使用倒排索引实现。\n\n### 实现\nB-Tree：适合用作 > 或 < 这样的范围查询，是 MySQL 中最常使用的一种索引实现。\nR-Tree：用于处理多维数据的数据结构，可以对地理数据进行空间索引。不过实际业务场景中使用的比较少。\nHash：散列表索引，效率高于 B-Tree，但是不支持范围查找和排序等功能。实际使用的也比较少。\nFullText：全文索引，是一种记录关键字与对应文档关系的倒排索引。\n\n## 存储引擎\n* MyISAM：是 MySQL 官方提供的存储引擎，其特点是支持全文索引，查询效率比较高，缺点是不支持事务、使用**表级锁**。\n* InnoDB：5.5版本后默认引擎。特点是支持 ACID 事务、支持外键、支持**行级锁**提高了并发效率。\n* TokuDB：是第三方开发的开源存储引擎，有非常快的写速度，支持数据的压缩存储、可以在线添加索引而不影响读写操作。但是因为压缩的原因，TokuDB 非常适合访问频率不高的数据或历史数据归档，不适合大量读取的场景。\n\n## 锁\n* 表锁：开销小，加锁快，不会出现死锁；但是锁的粒度大，发生锁冲突的概率高，并发访问效率比较低。\n* 行级锁：开销大，加锁慢，有可能会出现死锁，不过因为锁定粒度最小，发生锁冲突的概率低，并发访问效率比较高\n* 共享锁：读锁，其他事务可以读，但不能写。MySQL 可以通过 lock in share mode 语句显示使用共享锁。\n* 排他锁：写锁，其他事务不能读取，也不能写。对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会自动给涉及的数据集加排他锁，或者使用 select for update 显示使用排他锁。\n\n## 经验","slug":"20181113","published":1,"date":"2021-07-29T02:57:29.351Z","updated":"2021-07-29T07:05:06.374Z","_id":"ckrnhewl1000ieg0mgozf38em","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"调优\"><a href=\"#调优\" class=\"headerlink\" title=\"调优\"></a>调优</h2><p><img src=\"http://s0.lgstatic.com/i/image2/M01/8A/CF/CgoB5l14tcCAW4TEAAA4gPziGLI076.png\" alt=\"img\"><br>这四个纬度从优化的成本角度来讲，从左到右优化成本逐渐升高；从优化效果角度来看，从右到左优化的效果更高。</p>\n<h3 id=\"表结构及索引优化\"><a href=\"#表结构及索引优化\" class=\"headerlink\" title=\"表结构及索引优化\"></a>表结构及索引优化</h3><ul>\n<li>在设计表结构时，考虑数据库的水平与垂直扩展能力，提前规划好未来1年的数据量、读写量的增长，规划好分库分表方案。比如设计用户信息表，预计 1 年后用户数据 10亿 条，写 QPS 约 5000，读 QPS 30000，可以设计按 UID 纬度进行散列，分为 4 个库每个库 32 张表，单表数据量控制在 KW 级别。</li>\n<li>为字段选择合适的数据类型，在保留扩展能力的前提下，优先选用较小的数据结构。例如保存年龄的字段，要使用 TINYINT 而不要使用 INT。</li>\n<li>控制表的列数。</li>\n<li>如果查询时需要对多张表进行关联查询，可以设计一些冗余字段提高效率。</li>\n<li>要擅用索引，比如为经常作为查询条件的字段创建索引、创建联合索引时要根据最左原则考虑索引的复用能力，不要重复创建索引；要为保证数据不能重复的字段创建唯一索引等等。不过要注意索引对插入、更新等写操作是有代价的，不要滥用索引，比如像性别这样唯一很差的字段就不适合建立索引。</li>\n<li>列字段尽量设置为 not null。MySQL 难以对使用 null 的列进行查询优化，允许 null 会使索引、索引统计和值更加复杂，允许 null 值的列需要更多的存储空间，还需要 MySQL 内部进行特殊处理。</li>\n</ul>\n<h3 id=\"SQL语句优化\"><a href=\"#SQL语句优化\" class=\"headerlink\" title=\"SQL语句优化\"></a>SQL语句优化</h3><ul>\n<li>要找到最需要优化的 SQL 语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询 MySQL 的慢查询日志来发现需要进行优化的 SQL 语句。</li>\n<li>利用 MySQL 提供的分析工具。例如使用 Explain 来分析语句的执行计划，看看是否使用了索引，使用了哪个索引，扫描了多少记录，是否使用文件排序等等。或者利用 Profile 命令来分析某个语句执行过程中各个分步的耗时。</li>\n<li>要注意使用查询语句是要避免使用 SELECT *，而是应该指定具体需要获取的字段。原因一是可以避免查询出不需要使用的字段，二是可以避免查询列字段的元信息。</li>\n<li>尽量使用 prepared statements，一个是它性能更好，另一个是可以防止 SQL 注入。</li>\n<li>尽量使用索引扫描来进行排序，也就是尽量在有索引的字段上进行排序操作。</li>\n</ul>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><p>索引可以大幅增加数据库的查询的性能，但是索引也是有代价的，首先需要额外的磁盘空间来保存索引；其次，对于插入、更新、删除等操作由于更新索引会增加额外的开销，因此索引比较适合用在读多写少的场景。</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ul>\n<li>聚簇索引</li>\n<li>非聚簇索引</li>\n<li>唯一索引：索引列中的值必须是唯一的，但是允许出现空值。</li>\n<li>主键索引：一种特殊的唯一索引，但是它不允许出现空值。</li>\n<li>普通索引：唯一索引不同，它允许索引列中存在相同的值。</li>\n<li>联合索引：由多个列共同组成的索引，需遵循最左原则，就是 where 查询条件中的字段必须与索引字段从左到右进行匹配。</li>\n<li>全文索引：全文索引只能在 CHAR、VARCHAR、TEXT 类型字段上使用，底层使用倒排索引实现。</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>B-Tree：适合用作 &gt; 或 &lt; 这样的范围查询，是 MySQL 中最常使用的一种索引实现。<br>R-Tree：用于处理多维数据的数据结构，可以对地理数据进行空间索引。不过实际业务场景中使用的比较少。<br>Hash：散列表索引，效率高于 B-Tree，但是不支持范围查找和排序等功能。实际使用的也比较少。<br>FullText：全文索引，是一种记录关键字与对应文档关系的倒排索引。</p>\n<h2 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h2><ul>\n<li>MyISAM：是 MySQL 官方提供的存储引擎，其特点是支持全文索引，查询效率比较高，缺点是不支持事务、使用<strong>表级锁</strong>。</li>\n<li>InnoDB：5.5版本后默认引擎。特点是支持 ACID 事务、支持外键、支持<strong>行级锁</strong>提高了并发效率。</li>\n<li>TokuDB：是第三方开发的开源存储引擎，有非常快的写速度，支持数据的压缩存储、可以在线添加索引而不影响读写操作。但是因为压缩的原因，TokuDB 非常适合访问频率不高的数据或历史数据归档，不适合大量读取的场景。</li>\n</ul>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><ul>\n<li>表锁：开销小，加锁快，不会出现死锁；但是锁的粒度大，发生锁冲突的概率高，并发访问效率比较低。</li>\n<li>行级锁：开销大，加锁慢，有可能会出现死锁，不过因为锁定粒度最小，发生锁冲突的概率低，并发访问效率比较高</li>\n<li>共享锁：读锁，其他事务可以读，但不能写。MySQL 可以通过 lock in share mode 语句显示使用共享锁。</li>\n<li>排他锁：写锁，其他事务不能读取，也不能写。对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会自动给涉及的数据集加排他锁，或者使用 select for update 显示使用排他锁。</li>\n</ul>\n<h2 id=\"经验\"><a href=\"#经验\" class=\"headerlink\" title=\"经验\"></a>经验</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"调优\"><a href=\"#调优\" class=\"headerlink\" title=\"调优\"></a>调优</h2><p><img src=\"http://s0.lgstatic.com/i/image2/M01/8A/CF/CgoB5l14tcCAW4TEAAA4gPziGLI076.png\" alt=\"img\"><br>这四个纬度从优化的成本角度来讲，从左到右优化成本逐渐升高；从优化效果角度来看，从右到左优化的效果更高。</p>\n<h3 id=\"表结构及索引优化\"><a href=\"#表结构及索引优化\" class=\"headerlink\" title=\"表结构及索引优化\"></a>表结构及索引优化</h3><ul>\n<li>在设计表结构时，考虑数据库的水平与垂直扩展能力，提前规划好未来1年的数据量、读写量的增长，规划好分库分表方案。比如设计用户信息表，预计 1 年后用户数据 10亿 条，写 QPS 约 5000，读 QPS 30000，可以设计按 UID 纬度进行散列，分为 4 个库每个库 32 张表，单表数据量控制在 KW 级别。</li>\n<li>为字段选择合适的数据类型，在保留扩展能力的前提下，优先选用较小的数据结构。例如保存年龄的字段，要使用 TINYINT 而不要使用 INT。</li>\n<li>控制表的列数。</li>\n<li>如果查询时需要对多张表进行关联查询，可以设计一些冗余字段提高效率。</li>\n<li>要擅用索引，比如为经常作为查询条件的字段创建索引、创建联合索引时要根据最左原则考虑索引的复用能力，不要重复创建索引；要为保证数据不能重复的字段创建唯一索引等等。不过要注意索引对插入、更新等写操作是有代价的，不要滥用索引，比如像性别这样唯一很差的字段就不适合建立索引。</li>\n<li>列字段尽量设置为 not null。MySQL 难以对使用 null 的列进行查询优化，允许 null 会使索引、索引统计和值更加复杂，允许 null 值的列需要更多的存储空间，还需要 MySQL 内部进行特殊处理。</li>\n</ul>\n<h3 id=\"SQL语句优化\"><a href=\"#SQL语句优化\" class=\"headerlink\" title=\"SQL语句优化\"></a>SQL语句优化</h3><ul>\n<li>要找到最需要优化的 SQL 语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询 MySQL 的慢查询日志来发现需要进行优化的 SQL 语句。</li>\n<li>利用 MySQL 提供的分析工具。例如使用 Explain 来分析语句的执行计划，看看是否使用了索引，使用了哪个索引，扫描了多少记录，是否使用文件排序等等。或者利用 Profile 命令来分析某个语句执行过程中各个分步的耗时。</li>\n<li>要注意使用查询语句是要避免使用 SELECT *，而是应该指定具体需要获取的字段。原因一是可以避免查询出不需要使用的字段，二是可以避免查询列字段的元信息。</li>\n<li>尽量使用 prepared statements，一个是它性能更好，另一个是可以防止 SQL 注入。</li>\n<li>尽量使用索引扫描来进行排序，也就是尽量在有索引的字段上进行排序操作。</li>\n</ul>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><p>索引可以大幅增加数据库的查询的性能，但是索引也是有代价的，首先需要额外的磁盘空间来保存索引；其次，对于插入、更新、删除等操作由于更新索引会增加额外的开销，因此索引比较适合用在读多写少的场景。</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ul>\n<li>聚簇索引</li>\n<li>非聚簇索引</li>\n<li>唯一索引：索引列中的值必须是唯一的，但是允许出现空值。</li>\n<li>主键索引：一种特殊的唯一索引，但是它不允许出现空值。</li>\n<li>普通索引：唯一索引不同，它允许索引列中存在相同的值。</li>\n<li>联合索引：由多个列共同组成的索引，需遵循最左原则，就是 where 查询条件中的字段必须与索引字段从左到右进行匹配。</li>\n<li>全文索引：全文索引只能在 CHAR、VARCHAR、TEXT 类型字段上使用，底层使用倒排索引实现。</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>B-Tree：适合用作 &gt; 或 &lt; 这样的范围查询，是 MySQL 中最常使用的一种索引实现。<br>R-Tree：用于处理多维数据的数据结构，可以对地理数据进行空间索引。不过实际业务场景中使用的比较少。<br>Hash：散列表索引，效率高于 B-Tree，但是不支持范围查找和排序等功能。实际使用的也比较少。<br>FullText：全文索引，是一种记录关键字与对应文档关系的倒排索引。</p>\n<h2 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h2><ul>\n<li>MyISAM：是 MySQL 官方提供的存储引擎，其特点是支持全文索引，查询效率比较高，缺点是不支持事务、使用<strong>表级锁</strong>。</li>\n<li>InnoDB：5.5版本后默认引擎。特点是支持 ACID 事务、支持外键、支持<strong>行级锁</strong>提高了并发效率。</li>\n<li>TokuDB：是第三方开发的开源存储引擎，有非常快的写速度，支持数据的压缩存储、可以在线添加索引而不影响读写操作。但是因为压缩的原因，TokuDB 非常适合访问频率不高的数据或历史数据归档，不适合大量读取的场景。</li>\n</ul>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><ul>\n<li>表锁：开销小，加锁快，不会出现死锁；但是锁的粒度大，发生锁冲突的概率高，并发访问效率比较低。</li>\n<li>行级锁：开销大，加锁慢，有可能会出现死锁，不过因为锁定粒度最小，发生锁冲突的概率低，并发访问效率比较高</li>\n<li>共享锁：读锁，其他事务可以读，但不能写。MySQL 可以通过 lock in share mode 语句显示使用共享锁。</li>\n<li>排他锁：写锁，其他事务不能读取，也不能写。对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会自动给涉及的数据集加排他锁，或者使用 select for update 显示使用排他锁。</li>\n</ul>\n<h2 id=\"经验\"><a href=\"#经验\" class=\"headerlink\" title=\"经验\"></a>经验</h2>"},{"title":"HBase","_content":"\n## 索引类型\n* 本地索引\n* 全局索引\n* 覆盖索引\n\n## RowKey设计\n* 长度原则\n* 唯一原则\n* 散列原则\n\n## 参考文章\n* [HBase技术细节笔记上](https://cloud.tencent.com/developer/article/1006043)\n* [HBase技术细节笔记下](https://cloud.tencent.com/developer/article/1006044)\n* [我终于看懂了HBase，太不容易了](https://zhuanlan.zhihu.com/p/145551967)\n* [2018 HBase技术总结](https://www.slidestalk.com/HBaseGroup/HBase_ebook28532)","source":"_posts/20181114.md","raw":"---\ntitle: HBase\ncategory: 应用模块\ntag: 数据库\n---\n\n## 索引类型\n* 本地索引\n* 全局索引\n* 覆盖索引\n\n## RowKey设计\n* 长度原则\n* 唯一原则\n* 散列原则\n\n## 参考文章\n* [HBase技术细节笔记上](https://cloud.tencent.com/developer/article/1006043)\n* [HBase技术细节笔记下](https://cloud.tencent.com/developer/article/1006044)\n* [我终于看懂了HBase，太不容易了](https://zhuanlan.zhihu.com/p/145551967)\n* [2018 HBase技术总结](https://www.slidestalk.com/HBaseGroup/HBase_ebook28532)","slug":"20181114","published":1,"date":"2021-07-29T02:57:29.352Z","updated":"2021-07-29T02:57:29.353Z","_id":"ckrnhewl1000jeg0m2y8o0fyb","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"索引类型\"><a href=\"#索引类型\" class=\"headerlink\" title=\"索引类型\"></a>索引类型</h2><ul>\n<li>本地索引</li>\n<li>全局索引</li>\n<li>覆盖索引</li>\n</ul>\n<h2 id=\"RowKey设计\"><a href=\"#RowKey设计\" class=\"headerlink\" title=\"RowKey设计\"></a>RowKey设计</h2><ul>\n<li>长度原则</li>\n<li>唯一原则</li>\n<li>散列原则</li>\n</ul>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://cloud.tencent.com/developer/article/1006043\" target=\"_blank\" rel=\"external\">HBase技术细节笔记上</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1006044\" target=\"_blank\" rel=\"external\">HBase技术细节笔记下</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/145551967\" target=\"_blank\" rel=\"external\">我终于看懂了HBase，太不容易了</a></li>\n<li><a href=\"https://www.slidestalk.com/HBaseGroup/HBase_ebook28532\" target=\"_blank\" rel=\"external\">2018 HBase技术总结</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"索引类型\"><a href=\"#索引类型\" class=\"headerlink\" title=\"索引类型\"></a>索引类型</h2><ul>\n<li>本地索引</li>\n<li>全局索引</li>\n<li>覆盖索引</li>\n</ul>\n<h2 id=\"RowKey设计\"><a href=\"#RowKey设计\" class=\"headerlink\" title=\"RowKey设计\"></a>RowKey设计</h2><ul>\n<li>长度原则</li>\n<li>唯一原则</li>\n<li>散列原则</li>\n</ul>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://cloud.tencent.com/developer/article/1006043\" target=\"_blank\" rel=\"external\">HBase技术细节笔记上</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1006044\" target=\"_blank\" rel=\"external\">HBase技术细节笔记下</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/145551967\" target=\"_blank\" rel=\"external\">我终于看懂了HBase，太不容易了</a></li>\n<li><a href=\"https://www.slidestalk.com/HBaseGroup/HBase_ebook28532\" target=\"_blank\" rel=\"external\">2018 HBase技术总结</a></li>\n</ul>\n"},{"title":"Cassandra","_content":"","source":"_posts/20181115.md","raw":"---\ntitle: Cassandra\ncategory: 应用模块\ntag: 数据库\n---","slug":"20181115","published":1,"date":"2021-07-29T02:57:29.354Z","updated":"2021-07-29T02:57:29.354Z","_id":"ckrnhewl2000keg0mhqhysnku","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"架构","_content":"\n# CAP理论\nConsistency: 一致性，所有节点访问同一份最新的数据副本\nAvailability: 可用性，非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。\nPartition tolerance: 分区容错性，分布式系统出现网络分区的时候，仍然能够对外提供服务。\n在一个分布式系统中，这三个特性最多只能同时满足两个，三者不可兼得。\n\n## CA\n放弃分区容错，这也就等同于放弃了分布式系统，所以 CA 只存在于单机系统。\n## CP\n选择强一致和分区容错，允许极端情况下出现短时的服务不可用。\nCP实现的系统：ZooKeeper、Consul、Etcd、HBase、Nacos\n## AP\n选择分区容错和高可用，允许数据出现短时间不一致。在服务注册的场景，短期的不一致一般不会对服务交互产生影响，因此采用 AP 原则的注册中心才是微服务比较适合的选择。\nAP实现的系统：Eureka、Nacos、Cassandra\n\n# BASE\nBasically Available：基本可用\nSoft-state：软状态\nEventual Consistency：最终一致性\n它是对 CAP 中一致性和可用性权衡的结果。BASE 的核心思想是即使无法做到强一致性，也可以根据系统特点，采用适当的方式达到最终一致性。","source":"_posts/20190112.md","raw":"---\ntitle: 架构\ncategory: 综合模块\n---\n\n# CAP理论\nConsistency: 一致性，所有节点访问同一份最新的数据副本\nAvailability: 可用性，非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。\nPartition tolerance: 分区容错性，分布式系统出现网络分区的时候，仍然能够对外提供服务。\n在一个分布式系统中，这三个特性最多只能同时满足两个，三者不可兼得。\n\n## CA\n放弃分区容错，这也就等同于放弃了分布式系统，所以 CA 只存在于单机系统。\n## CP\n选择强一致和分区容错，允许极端情况下出现短时的服务不可用。\nCP实现的系统：ZooKeeper、Consul、Etcd、HBase、Nacos\n## AP\n选择分区容错和高可用，允许数据出现短时间不一致。在服务注册的场景，短期的不一致一般不会对服务交互产生影响，因此采用 AP 原则的注册中心才是微服务比较适合的选择。\nAP实现的系统：Eureka、Nacos、Cassandra\n\n# BASE\nBasically Available：基本可用\nSoft-state：软状态\nEventual Consistency：最终一致性\n它是对 CAP 中一致性和可用性权衡的结果。BASE 的核心思想是即使无法做到强一致性，也可以根据系统特点，采用适当的方式达到最终一致性。","slug":"20190112","published":1,"date":"2021-07-29T02:57:29.357Z","updated":"2021-07-29T02:57:29.357Z","_id":"ckrnhewl2000leg0m127lsdjb","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"CAP理论\"><a href=\"#CAP理论\" class=\"headerlink\" title=\"CAP理论\"></a>CAP理论</h1><p>Consistency: 一致性，所有节点访问同一份最新的数据副本<br>Availability: 可用性，非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。<br>Partition tolerance: 分区容错性，分布式系统出现网络分区的时候，仍然能够对外提供服务。<br>在一个分布式系统中，这三个特性最多只能同时满足两个，三者不可兼得。</p>\n<h2 id=\"CA\"><a href=\"#CA\" class=\"headerlink\" title=\"CA\"></a>CA</h2><p>放弃分区容错，这也就等同于放弃了分布式系统，所以 CA 只存在于单机系统。</p>\n<h2 id=\"CP\"><a href=\"#CP\" class=\"headerlink\" title=\"CP\"></a>CP</h2><p>选择强一致和分区容错，允许极端情况下出现短时的服务不可用。<br>CP实现的系统：ZooKeeper、Consul、Etcd、HBase、Nacos</p>\n<h2 id=\"AP\"><a href=\"#AP\" class=\"headerlink\" title=\"AP\"></a>AP</h2><p>选择分区容错和高可用，允许数据出现短时间不一致。在服务注册的场景，短期的不一致一般不会对服务交互产生影响，因此采用 AP 原则的注册中心才是微服务比较适合的选择。<br>AP实现的系统：Eureka、Nacos、Cassandra</p>\n<h1 id=\"BASE\"><a href=\"#BASE\" class=\"headerlink\" title=\"BASE\"></a>BASE</h1><p>Basically Available：基本可用<br>Soft-state：软状态<br>Eventual Consistency：最终一致性<br>它是对 CAP 中一致性和可用性权衡的结果。BASE 的核心思想是即使无法做到强一致性，也可以根据系统特点，采用适当的方式达到最终一致性。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CAP理论\"><a href=\"#CAP理论\" class=\"headerlink\" title=\"CAP理论\"></a>CAP理论</h1><p>Consistency: 一致性，所有节点访问同一份最新的数据副本<br>Availability: 可用性，非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。<br>Partition tolerance: 分区容错性，分布式系统出现网络分区的时候，仍然能够对外提供服务。<br>在一个分布式系统中，这三个特性最多只能同时满足两个，三者不可兼得。</p>\n<h2 id=\"CA\"><a href=\"#CA\" class=\"headerlink\" title=\"CA\"></a>CA</h2><p>放弃分区容错，这也就等同于放弃了分布式系统，所以 CA 只存在于单机系统。</p>\n<h2 id=\"CP\"><a href=\"#CP\" class=\"headerlink\" title=\"CP\"></a>CP</h2><p>选择强一致和分区容错，允许极端情况下出现短时的服务不可用。<br>CP实现的系统：ZooKeeper、Consul、Etcd、HBase、Nacos</p>\n<h2 id=\"AP\"><a href=\"#AP\" class=\"headerlink\" title=\"AP\"></a>AP</h2><p>选择分区容错和高可用，允许数据出现短时间不一致。在服务注册的场景，短期的不一致一般不会对服务交互产生影响，因此采用 AP 原则的注册中心才是微服务比较适合的选择。<br>AP实现的系统：Eureka、Nacos、Cassandra</p>\n<h1 id=\"BASE\"><a href=\"#BASE\" class=\"headerlink\" title=\"BASE\"></a>BASE</h1><p>Basically Available：基本可用<br>Soft-state：软状态<br>Eventual Consistency：最终一致性<br>它是对 CAP 中一致性和可用性权衡的结果。BASE 的核心思想是即使无法做到强一致性，也可以根据系统特点，采用适当的方式达到最终一致性。</p>\n"},{"title":"Mongo","_content":"\n## 索引\n\n* 单键索引\n* 复合索引\n* 多键值索引\n* 地理索引\n* 全文索引\n* 散列索引\n\n* 稀疏索引\n* 唯一索引\n* 过期索引\n\n## 部署方式\n分片\n副本集","source":"_posts/20190107.md","raw":"---\ntitle: Mongo\ncategory: 应用模块\ntag: 数据库\n---\n\n## 索引\n\n* 单键索引\n* 复合索引\n* 多键值索引\n* 地理索引\n* 全文索引\n* 散列索引\n\n* 稀疏索引\n* 唯一索引\n* 过期索引\n\n## 部署方式\n分片\n副本集","slug":"20190107","published":1,"date":"2021-07-29T02:57:29.356Z","updated":"2021-07-29T02:57:29.356Z","_id":"ckrnhewl3000meg0mpmxs9i9w","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><ul>\n<li>单键索引</li>\n<li>复合索引</li>\n<li>多键值索引</li>\n<li>地理索引</li>\n<li>全文索引</li>\n<li><p>散列索引</p>\n</li>\n<li><p>稀疏索引</p>\n</li>\n<li>唯一索引</li>\n<li>过期索引</li>\n</ul>\n<h2 id=\"部署方式\"><a href=\"#部署方式\" class=\"headerlink\" title=\"部署方式\"></a>部署方式</h2><p>分片<br>副本集</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><ul>\n<li>单键索引</li>\n<li>复合索引</li>\n<li>多键值索引</li>\n<li>地理索引</li>\n<li>全文索引</li>\n<li><p>散列索引</p>\n</li>\n<li><p>稀疏索引</p>\n</li>\n<li>唯一索引</li>\n<li>过期索引</li>\n</ul>\n<h2 id=\"部署方式\"><a href=\"#部署方式\" class=\"headerlink\" title=\"部署方式\"></a>部署方式</h2><p>分片<br>副本集</p>\n"},{"title":"数据格式","_content":"\n## ProtoBuf\nProtocol Buffer 简称 protobuf，google开源的一种数据传输格式，类似于json，但比json的体积要小，速度更快，并且跨平台、跨语言。使用时需编写.proto文件，然后使用protocol.exe生成特定语言的文件。序列化和反序列化需使用同一个文件。\nprotobuf按照Tag + 可选（长度） + 值进行存储，不存储真正的属性名，而是在解析时按照Tag去寻找对应的属性名，然后对其进行赋值。\nProtostuff是为了简化生成中间文件而生的开源项目。\n都是Java语言时，客户端和服务端类名、属性、类型需保持一致。包名也必须一致？\n服务端Java、客户端Python时，客户端需定义Message。对于泛型的处理，需要经过调试才能知道各种类型的Tag。\n同时需注意客户端与服务端的protobuf的版本必须一致，目前主要版本为2.0、3.0。\n\n## JSON\n","source":"_posts/20210728.md","raw":"---\ntitle: 数据格式\ncategory: 基础模块\n---\n\n## ProtoBuf\nProtocol Buffer 简称 protobuf，google开源的一种数据传输格式，类似于json，但比json的体积要小，速度更快，并且跨平台、跨语言。使用时需编写.proto文件，然后使用protocol.exe生成特定语言的文件。序列化和反序列化需使用同一个文件。\nprotobuf按照Tag + 可选（长度） + 值进行存储，不存储真正的属性名，而是在解析时按照Tag去寻找对应的属性名，然后对其进行赋值。\nProtostuff是为了简化生成中间文件而生的开源项目。\n都是Java语言时，客户端和服务端类名、属性、类型需保持一致。包名也必须一致？\n服务端Java、客户端Python时，客户端需定义Message。对于泛型的处理，需要经过调试才能知道各种类型的Tag。\n同时需注意客户端与服务端的protobuf的版本必须一致，目前主要版本为2.0、3.0。\n\n## JSON\n","slug":"20210728","published":1,"date":"2021-07-29T02:57:29.358Z","updated":"2021-07-29T02:57:29.358Z","_id":"ckrnhwqn10000oe0mdgnbfuou","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"ProtoBuf\"><a href=\"#ProtoBuf\" class=\"headerlink\" title=\"ProtoBuf\"></a>ProtoBuf</h2><p>Protocol Buffer 简称 protobuf，google开源的一种数据传输格式，类似于json，但比json的体积要小，速度更快，并且跨平台、跨语言。使用时需编写.proto文件，然后使用protocol.exe生成特定语言的文件。序列化和反序列化需使用同一个文件。<br>protobuf按照Tag + 可选（长度） + 值进行存储，不存储真正的属性名，而是在解析时按照Tag去寻找对应的属性名，然后对其进行赋值。<br>Protostuff是为了简化生成中间文件而生的开源项目。<br>都是Java语言时，客户端和服务端类名、属性、类型需保持一致。包名也必须一致？<br>服务端Java、客户端Python时，客户端需定义Message。对于泛型的处理，需要经过调试才能知道各种类型的Tag。<br>同时需注意客户端与服务端的protobuf的版本必须一致，目前主要版本为2.0、3.0。</p>\n<h2 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ProtoBuf\"><a href=\"#ProtoBuf\" class=\"headerlink\" title=\"ProtoBuf\"></a>ProtoBuf</h2><p>Protocol Buffer 简称 protobuf，google开源的一种数据传输格式，类似于json，但比json的体积要小，速度更快，并且跨平台、跨语言。使用时需编写.proto文件，然后使用protocol.exe生成特定语言的文件。序列化和反序列化需使用同一个文件。<br>protobuf按照Tag + 可选（长度） + 值进行存储，不存储真正的属性名，而是在解析时按照Tag去寻找对应的属性名，然后对其进行赋值。<br>Protostuff是为了简化生成中间文件而生的开源项目。<br>都是Java语言时，客户端和服务端类名、属性、类型需保持一致。包名也必须一致？<br>服务端Java、客户端Python时，客户端需定义Message。对于泛型的处理，需要经过调试才能知道各种类型的Tag。<br>同时需注意客户端与服务端的protobuf的版本必须一致，目前主要版本为2.0、3.0。</p>\n<h2 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h2>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckrnhewkl0001eg0mqj56vt65","category_id":"ckrnl9zmx0001ny0mjbrxfm0s","_id":"ckrnl9zn00002ny0mmvx1j8j5"},{"post_id":"ckrnhewkq0005eg0mfw3pflxo","category_id":"ckrnl9zmx0001ny0mjbrxfm0s","_id":"ckrnlbk8m0003ny0mbvsw1g3w"},{"post_id":"ckrnhewkp0004eg0m6bjjn0cm","category_id":"ckrnl9zmx0001ny0mjbrxfm0s","_id":"ckrnld2zc0004ny0myje36c5g"},{"post_id":"ckrnhewkr0006eg0mr3rdwfax","category_id":"ckrnl9zmx0001ny0mjbrxfm0s","_id":"ckrnld2zg0005ny0mo6kyksul"},{"post_id":"ckrnhewkr0007eg0mbhwhf3gw","category_id":"ckrnl9zmx0001ny0mjbrxfm0s","_id":"ckrnld2zg0006ny0mus7kh6be"},{"post_id":"ckrnhewks0008eg0mnwpks1wh","category_id":"ckrnl9zmx0001ny0mjbrxfm0s","_id":"ckrnld2zg0008ny0m77190zof"},{"post_id":"ckrnhewkt0009eg0mqm1lw41y","category_id":"ckrnldpot0009ny0m2rsctnzz","_id":"ckrnldpov000bny0mi91shgj5"},{"post_id":"ckrnhewku000aeg0moljl7jh0","category_id":"ckrnldpot0009ny0m2rsctnzz","_id":"ckrnldpov000cny0md8ftpgl7"},{"post_id":"ckrnhewl0000geg0m99n8jz6w","category_id":"ckrnldpot0009ny0m2rsctnzz","_id":"ckrnleqtu000dny0mb84g1if3"},{"post_id":"ckrnhewl2000keg0mhqhysnku","category_id":"ckrnldpot0009ny0m2rsctnzz","_id":"ckrnleqtv000eny0m2of1vrku"},{"post_id":"ckrnhewl1000ieg0mgozf38em","category_id":"ckrnldpot0009ny0m2rsctnzz","_id":"ckrnleqtv000fny0myeuygnyy"},{"post_id":"ckrnhewkz000feg0mbgurr2u4","category_id":"ckrnldpot0009ny0m2rsctnzz","_id":"ckrnleqtv000gny0mqscueym9"},{"post_id":"ckrnhewkv000beg0mjdw5h9vz","category_id":"ckrnldpot0009ny0m2rsctnzz","_id":"ckrnleqtv000hny0mxnyl2m1l"},{"post_id":"ckrnhewky000eeg0mgbk9hxmv","category_id":"ckrnldpot0009ny0m2rsctnzz","_id":"ckrnleqtv000iny0m7p1zqrpn"},{"post_id":"ckrnhewkx000deg0m7mo5jy12","category_id":"ckrnldpot0009ny0m2rsctnzz","_id":"ckrnleqtv000jny0mdp9tsyc5"},{"post_id":"ckrnhewl0000heg0mena1cb43","category_id":"ckrnldpot0009ny0m2rsctnzz","_id":"ckrnleqtv000kny0mbz2qckem"},{"post_id":"ckrnhewl1000jeg0m2y8o0fyb","category_id":"ckrnldpot0009ny0m2rsctnzz","_id":"ckrnleqtv000lny0m1r0n8v4e"},{"post_id":"ckrnhewl3000meg0mpmxs9i9w","category_id":"ckrnldpot0009ny0m2rsctnzz","_id":"ckrnleqtw000mny0msvtmh8vo"},{"post_id":"ckrnhewkw000ceg0mfie5wwtu","category_id":"ckrnldpot0009ny0m2rsctnzz","_id":"ckrnleqtw000nny0mx07od78a"},{"post_id":"ckrnhewl2000leg0m127lsdjb","category_id":"ckrnlf8r3000ony0md8mgqhtq","_id":"ckrnlf8r4000pny0m04w57fol"},{"post_id":"ckrnhwqn10000oe0mdgnbfuou","category_id":"ckrnl9zmx0001ny0mjbrxfm0s","_id":"ckrnlf8r4000qny0matcaakq7"},{"post_id":"ckrnhewko0003eg0mrjfywis0","category_id":"ckrnlf8r3000ony0md8mgqhtq","_id":"ckrnlgtf6000rny0mt4som1rr"}],"PostTag":[{"post_id":"ckrnhewl2000keg0mhqhysnku","tag_id":"ckrnljjb2000sny0me9toltor","_id":"ckrnljjb6000tny0mnln49m1x"},{"post_id":"ckrnhewl1000jeg0m2y8o0fyb","tag_id":"ckrnljjb2000sny0me9toltor","_id":"ckrnljjb6000uny0m9e2qt4wx"},{"post_id":"ckrnhewl3000meg0mpmxs9i9w","tag_id":"ckrnljjb2000sny0me9toltor","_id":"ckrnljjb6000vny0mori3xqnt"},{"post_id":"ckrnhewl1000ieg0mgozf38em","tag_id":"ckrnljjb2000sny0me9toltor","_id":"ckrnljjb6000wny0m6yo241uw"},{"post_id":"ckrnhewkz000feg0mbgurr2u4","tag_id":"ckrnljjb2000sny0me9toltor","_id":"ckrnln5dm000xny0mh1l8da8n"},{"post_id":"ckrnhewl0000geg0m99n8jz6w","tag_id":"ckrnln5dm000yny0m19l8sjtt","_id":"ckrnln5dq000zny0m4rzoem12"},{"post_id":"ckrnhewkx000deg0m7mo5jy12","tag_id":"ckrnln5dm000yny0m19l8sjtt","_id":"ckrnln5dr0011ny0m1kh0a69a"},{"post_id":"ckrnhewky000eeg0mgbk9hxmv","tag_id":"ckrnln5dq0010ny0m0y5dj8s6","_id":"ckrnln5ds0013ny0m5fvorco0"},{"post_id":"ckrnhewl0000heg0mena1cb43","tag_id":"ckrnln5dq0010ny0m0y5dj8s6","_id":"ckrnln5ds0014ny0mbyhb9mtl"}],"Tag":[{"name":"数据库","_id":"ckrnljjb2000sny0me9toltor"},{"name":"消息队列","_id":"ckrnln5dm000yny0m19l8sjtt"},{"name":"缓存","_id":"ckrnln5dq0010ny0m0y5dj8s6"}]}}