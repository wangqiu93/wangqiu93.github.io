---
title: 缓存
category: 应用模块
tag: [缓存,中间件]
---

缓存是高并发场景下提高热点数据访问性能的一个有效手段，使用内存来保存数据。
<!--more-->

## 类型
* 本地缓存
    * Caffeine
* 分布式缓存
    * [Redis](/2021/07/29/20181111/)
    * Memcache
* 多级缓存：本地缓存 + 分布式缓存
实际业务中一般采用多级缓存，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中。

## 淘汰策略
由于成本和内存限制，当存储的数据超过缓存容量时，需要对缓存的数据进行剔除。
* FIFO：淘汰最早数据。
* LRU：剔除最近最少使用。
* LFU：剔除最近使用频率最低。

## 缓存常见问题
### 缓存更新方式
在数据源（可能是 DB，也可能是远程服务）发生变更时需要对缓存进行更新。
**DB：**

在更新完 DB 后就直接更新缓存

**远程服务**

- 对缓存数据设置失效期（数据不一致的最大容忍时间），key 不存在或失效时先请求数据源获取最新数据，然后再次缓存，并更新失效期。
- 定时对数据进行分批更新。

### 缓存不一致
主动更新失败，例如更新 DB 后，更新 Redis 因为网络原因请求超时；或者是异步更新失败导致。

- 服务对耗时不是特别敏感：可以增加重试。
- 服务对耗时不是特别敏感：可以通过异步补偿任务来处理失败的更新。
- 短期的数据不一致不会影响业务：那么只要下次更新时可以成功，能保证最终一致性就可以。

### 缓存穿透
缓存和数据库都没有的数据，而用户不断发起请求。可能是外部的恶意攻击。
* 对不存在的数据，在缓存中保存一个空对象进行标记，防止相同 ID 再次访问 DB。不过有时这个方法并不能很好解决问题，可能导致缓存中存储大量无用数据。
* 使用 BloomFilter 过滤器，BloomFilter 的特点是存在性检测，如果 BloomFilter 中不存在，那么数据一定不存在；如果 BloomFilter 中存在，实际数据也有可能会不存在。非常适合解决这类的问题。

### 缓存击穿
某个热点数据失效时，大量针对这个数据的请求会穿透到数据源。
* 可以使用互斥锁更新，保证同一个进程中针对同一个数据不会并发请求到 DB，减小 DB 压力。
* 使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新。



### 缓存雪崩：缓存挂掉
多个热点数据同时失效，大量请求会穿透到数据源。
* 可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效。