---
title: MySQL
category: 应用模块
tag: 数据库
---

## 调优
![img](/img/posts/索引优化.png)
这四个纬度从优化的成本角度来讲，从左到右优化成本逐渐升高；从优化效果角度来看，从右到左优化的效果更高。

### 表结构及索引优化
* 在设计表结构时，考虑数据库的水平与垂直扩展能力，提前规划好未来1年的数据量、读写量的增长，规划好分库分表方案。比如设计用户信息表，预计 1 年后用户数据 10亿 条，写 QPS 约 5000，读 QPS 30000，可以设计按 UID 纬度进行散列，分为 4 个库每个库 32 张表，单表数据量控制在 KW 级别。
* 为字段选择合适的数据类型，在保留扩展能力的前提下，优先选用较小的数据结构。例如保存年龄的字段，要使用 TINYINT 而不要使用 INT。
* 控制表的列数。
* 如果查询时需要对多张表进行关联查询，可以设计一些冗余字段提高效率。
* 要擅用索引，比如为经常作为查询条件的字段创建索引、创建联合索引时要根据最左原则考虑索引的复用能力，不要重复创建索引；要为保证数据不能重复的字段创建唯一索引等等。不过要注意索引对插入、更新等写操作是有代价的，不要滥用索引，比如像性别这样唯一很差的字段就不适合建立索引。
* 列字段尽量设置为 not null。MySQL 难以对使用 null 的列进行查询优化，允许 null 会使索引、索引统计和值更加复杂，允许 null 值的列需要更多的存储空间，还需要 MySQL 内部进行特殊处理。

### SQL语句优化
* 要找到最需要优化的 SQL 语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询 MySQL 的慢查询日志来发现需要进行优化的 SQL 语句。
* 利用 MySQL 提供的分析工具。例如使用 Explain 来分析语句的执行计划，看看是否使用了索引，使用了哪个索引，扫描了多少记录，是否使用文件排序等等。或者利用 Profile 命令来分析某个语句执行过程中各个分步的耗时。
* 要注意使用查询语句是要避免使用 SELECT *，而是应该指定具体需要获取的字段。原因一是可以避免查询出不需要使用的字段，二是可以避免查询列字段的元信息。
* 尽量使用 prepared statements，一个是它性能更好，另一个是可以防止 SQL 注入。
* 尽量使用索引扫描来进行排序，也就是尽量在有索引的字段上进行排序操作。

## 索引
索引可以大幅增加数据库的查询的性能，但是索引也是有代价的，首先需要额外的磁盘空间来保存索引；其次，对于插入、更新、删除等操作由于更新索引会增加额外的开销，因此索引比较适合用在读多写少的场景。
### 分类

* 唯一索引：索引列中的值必须是唯一的，但是允许出现空值。
* 主键索引：一种特殊的唯一索引，但是它不允许出现空值。
* 普通索引：唯一索引不同，它允许索引列中存在相同的值。
* 联合索引：由多个列共同组成的索引，需遵循最左原则，就是 where 查询条件中的字段必须与索引字段从左到右进行匹配。
* 全文索引：全文索引只能在 CHAR、VARCHAR、TEXT 类型字段上使用，底层使用倒排索引实现。

### 实现
B+树：适合用作 > 或 < 这样的范围查询，是 MySQL 中最常使用的一种索引实现。
R-Tree：用于处理多维数据的数据结构，可以对地理数据进行空间索引。不过实际业务场景中使用的比较少。
Hash：散列表索引，效率高于 B+树，但是不支持范围查找或排序等功能。实际使用的也比较少。
FullText：全文索引，是一种记录关键字与对应文档关系的倒排索引。

## 存储引擎

表级别设置。

![img](/img/posts/聚簇索引.png)

**聚簇索引**

B+树叶子节点上的data是行数据。

**非聚簇索引**

B+树的叶子节点上的data不是行数据。而是数据存放的地址或者主键值。

**回表查询**

先通过键值找到主键值，再通过主键值找到行记录，这个过程称为回表查询。

**覆盖索引**

当sql语句的所求查询字段（select列）和查询条件字段（where子句）全都包含在一个索引中（联合索引），可以直接使用索引查询而不需要回表。

### MyISAM

5.5版本前默认引擎，支持全文索引，查询效率比较高，但不支持事务、使用**表级锁**。

主键和辅助键均使用非聚簇索引。

### InnoDB

5.5版本后默认引擎。支持 ACID 事务、支持外键、支持**行级锁**。

主键使用聚簇索引，辅助键使用非聚簇索引。

### TokuDB

第三方开发的开源存储引擎，有非常快的写速度，支持数据的压缩存储、可以在线添加索引而不影响读写操作。但是因为压缩的原因，TokuDB 非常适合访问频率不高的数据或历史数据归档，不适合大量读取的场景。

## 锁
* 表锁：开销小，加锁快，不会出现死锁；但是锁的粒度大，发生锁冲突的概率高，并发访问效率比较低。
* 行级锁：开销大，加锁慢，有可能会出现死锁，不过因为锁定粒度最小，发生锁冲突的概率低，并发访问效率比较高
* 共享锁：读锁，其他事务可以读，但不能写。MySQL 可以通过 lock in share mode 语句显示使用共享锁。
* 排他锁：写锁，其他事务不能读取，也不能写。对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会自动给涉及的数据集加排他锁，或者使用 select for update 显示使用排他锁。

## 经验

## 参考文章

[姜承尧的MySQL实战宝典](https://www.jianshu.com/nb/50366127)

