---
title: 设计模式
category: 基础模块
---

设计模式分为 3 大类型共 23 种：
* **创建型**：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
* **结构型**：适配器模式、桥接模式、组合模式、装饰模式、门面模式、享元模式和代理模式。
* **行为型**：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。



<!-- more -->

# 创建型

## 单例模式

### 懒汉式，线程安全
~~~java
public class Singleton {
    private static Singleton instance;
    private Singleton (){}
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
~~~
### 双重检验锁
~~~java
public class Singleton {
    private volatile static Singleton instance;
    private Singleton (){}
    public static Singleton getSingleton() {
        if (instance == null) {                         
            synchronized (Singleton.class) {
                if (instance == null) {       
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
~~~
### 饿汉式
~~~java
public class Singleton{
    //类加载时就初始化
    private static final Singleton instance = new Singleton();
    private Singleton(){}
    public static Singleton getInstance(){
        return instance;
    }
}
~~~
### 静态内部类
~~~java
public class Singleton {  
    private static class SingletonHolder {  
        private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
        return SingletonHolder.INSTANCE; 
    }  
}
~~~
### 枚举
~~~java
public enum EasySingleton{
    INSTANCE;
}
~~~

# 结构型

## 适配器模式

使用频率：☆☆☆☆☆

定义：将类的接口转换为客户期望的另一个接口，适配器可以让不兼容的两个类一起协同工作。

关键角色：

- **目标类，** 适配器类即将要进行适配的抽象类或接口；
- **适配器类，** 可以是类或接口，是作为具体适配者类的中间类来使用；
- **具体适配者类，** 可以是内部的类或服务，也可以是外部对象或服务。

## 桥接模式

使用频率：☆☆☆☆☆

定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化。

关键角色：

- **抽象实体**：定义的一种抽象分类。比如，电脑中的 CPU、内存、摄像头、显示屏等。
- **具体实体**：继承抽象实体的子类实体。比如，Intel i7 CPU、三星内存、徕卡摄像头、京东方显示屏幕等。
- **抽象行为**：定义抽象实体中具备的多种行为。比如，CPU 逻辑运算、内存读写存储、摄像头拍照、屏幕显示图像等。
- **具体行为**：实现抽象行为的具体算法。比如，Intel 使用 X64 架构实现 CPU 逻辑运算，Mac M1 芯片使用 ARM 架构实现 CPU 逻辑运算，等等。

**桥接模式的本质是通过对一个对象进行实体与行为的分离，来将需要使用多层继承的场景转换为使用组合或聚合的方式，进而解耦对象间的强耦合关系，达到对象与对象之间的动态绑定的效果，提升代码结构的扩展性**。

## 代理模式

使用频率：☆☆☆☆☆

定义：让你能够提供对象的替代品或其[占位符。代理控制着对于原对象的访问，并允许将请求提交给对象前后进行一些处理。

关键角色：

- **抽象主题类（RealObject）**：声明公用的方法，定义可供客户端使用的统一功能。
- **主题实现类（RealObjectImpl）**：实现了抽象主题类的所有方法。
- **代理类（Proxy）**：实现了抽象主题类的方法，并隐藏在代理后面可能其他类的实现。

## 装饰模式

使用频率：☆☆☆☆☆

定义：允许动态地向一个现有的对象添加新的功能，同时又不改变其结构，相当于对现有的对象进行了一个包装。

关键角色：

- **组件**：作为装饰器类包装的目标类。
- **具体组件**：实现组件的基础子类。
- **装饰器**：一个抽象类，其中包含对组件的引用，并且还重写了组件接口方法。
- **具体装饰器**：继承扩展了装饰器，并重写组件接口方法，同时可以添加附加功能。

## 门面模式

使用频率：☆☆☆☆☆

定义：为子系统中的一组接口提供统一的接口。它定义了一个更高级别的接口，使子系统更易于使用。

关键角色：

- **门面系统**，负责处理依赖子系统的请求，并将请求代理给适当的子系统进行处理；
- **子系统**，代表某个领域内的功能实现，比如，订单、用户、支付等，专门处理由门面系统指派的任务。

## 组合模式

使用频率：☆

定义：将对象组合成树形结构以表示整个部分的层次结构。组合模式可以让用户统一对待单个对象和对象的组合。

关键角色：

## 享元模式

使用频率：☆

定义：摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，从而让我们能在有限的内存容量中载入更多对象。

关键角色：

- **享元类（Flyweight）**：定义了享元对象需要实现的公共操作方法。在该方法中会使用一个状态作为输入参数，也叫外部状态，由客户端保存，在运行时改变。
- **享元工厂类（Flyweight Factory）**：管理一个享元对象类的缓存池。它会存储享元对象之间需要传递的共有状态，比如，按照大写英文字母来作为状态标识，这种只在享元对象之间传递的方式就叫内部状态。同时，它还提供了一个通用方法 getFlyweight()，主要通过内部状态标识来获取享元对象。
- **可共享的具体享元类（ConcreteFlyweight）**：能够复用享元工厂内部状态并实现享元类公共操作的具体实现类。
- **非共享的具体享元类（UnsharedConcreteFlyweight）**：不复用享元工厂内部状态，但实现享元类的具体实现类。





# 行为型

## 观察者模式

使用频率：☆☆☆☆☆

定义：定义对象之间的一对多依赖关系，这样当一个对象改变状态时，它的所有依赖项都会自动得到通知和更新。

解释：相当于**订阅-发布模式；****基于事件驱动的架构**也是观察者模式的一种最佳实践

## 策略模式

使用频率：☆☆☆☆☆

定义：定义一系列算法，封装每个算法，并使它们可以互换。策略让算法独立于使用它的客户端而变化。



- **上下文信息类**（Context）：用于存放和执行需要使用的具体策略类以及客户端调用的逻辑。
- **抽象策略类**（Strategy）：定义策略的共有方法。
- **具体策略类**（StrategyA 等）：实现抽象策略类定义的共有方法。

## 模板方法模式

使用频率：☆☆☆☆

定义：在操作中定义算法的框架，将一些步骤推迟到子类中。模板方法让子类在不改变算法结构的情况下重新定义算法的某些步骤。



- **抽象父类**：定义一个算法所包含的所有步骤，并提供一些通用的方法逻辑。
- **具体子类**：继承自抽象父类，根据需要重写父类提供的算法步骤中的某些步骤。

## 中介者模式

使用频率：☆☆☆

定义：中介者对象封装了一组对象之间的交互，这组对象会将它们的交互委托给中介者对象，而不是直接交互。



- **抽象中介者**（Mediator）：定义中介者需要执行的方法操作。
- **具体中介者**（MediatorImpl）：实现抽象中介者定义的方法操作，同时可以包含更多逻辑。
- **抽象组件类**（Component）：定义组件需要执行的方法操作。
- **具体组件类**（ComponentA、ComponentB）：继承自抽象组件类，实现具体的组件业务逻辑。

## 状态模式

使用频率：☆☆☆

定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了自己的类一样。

- **上下文信息类**（Context）：实际上就是存储当前状态的类，对外提供更新状态的操作。
- **抽象状态类**（State）：可以是一个接口或抽象类，用于定义声明状态更新的操作方法有哪些。
- **具体状态类**（StateA 等）：实现抽象状态类定义的方法，根据具体的场景来指定对应状态改变后的代码实现逻辑。

## 责任链模式

使用频率：☆☆☆

定义：将一个请求封装为一个对象，从而让我们可以参数化具有不同请求、队列或日志请求的其他对象，并支持可撤销的操作。

解释：命令模式是为了将一组操作封装在对象中而设计的，简单来说，就是为了将函数方法封装为对象以方便传输。

## 迭代器模式

使用频率：☆

定义：迭代器提供一种对容器对象中的各个元素进行访问的方法，而又不需要暴露该对象的内部细节。

## 命令模式

使用频率：☆

定义：用于定义语言的语法规则表示，并提供解释器来处理句子中的语法

解释：相当于函数式编程

## 解释器模式

使用频率：☆

定义：用于定义语言的语法规则表示，并提供解释器来处理句子中的语法。

## 备忘录模式

使用频率：☆

定义：捕获并外部化对象的内部状态，以便以后可以恢复，所有这些都不会违反封装。

- **原始对象（Originator）**：除了创建自身所需要的属性和业务逻辑外，还通过提供方法 create() 和 restore(memento) 来保存和恢复对象副本。
- **备忘录（Memento）**：用于保存原始对象的所有属性状态，以便在未来进行撤销操作。

## 访问者模式

使用频率：☆

定义：允许在运行时将一个或多个操作应用于一组对象，将操作与对象结构分离。



# 参考文档

1. [拉钩教育之趣学设计模式](https://enterpc.blog.csdn.net/category_11435606.html)
