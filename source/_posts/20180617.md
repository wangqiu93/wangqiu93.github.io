---
title: Java
category: 基础模块
---

## 常用集合
### HashMap
底层实现：数组加链表，数组中的每一项是一个链表，链表中的节点存储的是键值对。通过计算存入对象的 HashCode，来计算对象在数组中要存入的位置。用链表来解决散列冲突，
#### 数组下标计算过程
~~~java
hash = (h = key.hashCode()) ^ (h >>> 16)
// n为数组长度，下面代码等价于 n % hash
(n - 1) & hash
~~~
1111 1101 1101 1111 0101 1101 0010 1111 ：key.hashCode()
0000 0000 0000 0000 1111 1101 1101 1111 ：h >>> 16
—————————————————————————————————————————————————————————
1111 1101 1101 1111 1010 0000 1111 0000 ：h ^ ( h >>> 16 )
0000 0000 0000 0000 0000 0000 0000 1111 ：16 - 1
—————————————————————————————————————————————————————————
0000 0000 0000 0000 0000 0000 0000 0000

总结：异或运算能更好的保留各部分的特征，如果采用&运算计算出来的值会向0靠拢，采用|运算计算出来的值会向1靠拢

#### 扩容机制
容量：默认为 1 <<< 4
加载因子：默认0.75
当元素数量超过阔值（容量 * 加载因子）时触发扩容，扩容后的容量是原容量的**2倍**。

#### 链表插入机制
1.7：头插法
1.8：尾插法

#### 链表转换为红黑树
1.8版本后为减少搜索时间，当链表长度大于阔值（默认8）且数组长度大于等于64时，链表会转换为**红黑树**。

单个 TreeNode 需要占用的空间大约是普通 Node 的两倍，所以只有当包含足够多的 Nodes 时才会转成 TreeNodes。
而当桶中节点数由于移除或者 resize 变少后，又会变回普通的链表的形式，以便节省空间。


参考文章[Java集合之一—HashMap](https://blog.csdn.net/woshimaxiao1/article/details/83661464)
### ConcurrentHashMap
1.7：使用 Segment （继承ReentrantLock，结构为数组加链表且均采用 volatile 修饰，保证获取时的可见性）进行分段加锁，降低并发锁定，支持 Segment 数组数量的线程并发。
1.8：抛弃了分段锁，使用 CAS + synchronized 来提高性能，并且同 hashMap 一样增加了红黑树。
参考文章：[HashMap？ConcurrentHashMap？相信看完这篇没人能难住你！](https://blog.csdn.net/weixin_44460333/article/details/86770169)


## JUC
### 原子类
例如：AtomicBoolean、AtomicLong、AtomicInteger、LongAdder、LongAccumulator等。
AtomicLong：通过 unsafe 类实现，基于CAS。
LongAdder：基于Cell，分段锁思想，空间换时间，更适合高并发场景。
LongAccumulator：提供了比LongAdder更强大的功能，能够指定对数据的操作规则，例如可以把对数据的相加操作改成相乘操作。
### 锁类
ReentrantLock
ReentrantReadWriteLock
StampedLock：JDK 1.8 改进的读写锁，是使用一种 CLH 的乐观锁，能够有效防止写饥饿。所谓写饥饿就是在多线程读写时，读线程访问非常频繁，导致总是有读线程占用资源，写线程很难加上写锁。
LockSupport
### 异步执行类
Executors：用于创建线程池
ForkJoinPool：1.7提供，采用分治思想，将大任务分解成多个小任务处理，然后在合并处理结果。特点是使用工作窃取算法，可以有效平衡多任务时间长短不一的场景。
FutureTask
CompletableFuture：可以支持流式调用，可以方便的进行多 future 的组合使用，例如可以同时执行两个异步任务，然后对执行结果进行合并处理。还可以很方便地设置完成时间。
### 阻塞队列类
LinkedBlockingDeque：双端队列，也就是可以分别从队头和队尾操作入队、出队。
ArrayBlockingQueue：单端队列，只能从队尾入队，队头出队。 
### 多线程协作类
CountDownLatch：实现计数器功能，可以用来控制等待多个线程执行任务后进行汇总。
CyclicBarrier：可以让一组线程等待至某个状态之后，再全部同时执行，一般在测试时使用，可以让多线程更好的并发执行。
Semaphore：用来控制对共享资源的访问并发度。允许多个线程共享资源，适用于限制使用共享资源线程数量的场景，例如 100 个车辆要使用 20 个停车位，那么最多允许 20 个车占用停车位。
### 集合类
ConcurrentHashMap：线程安全的HashMap。
CopyOnWriteArrayList：通过写入数据时进行 copy 修改，然后更新引用的方式，来消除并行读写中的锁使用，比较适合读多写少，数据量比较小，但是并发非常高的场景。

## 反射

## 动态代理

### JDK动态代理

### CGLIB动态代理
JDK 动态代理只能代理实现了接口的类或者直接代理接口；CGLIB 可以代理未实现任何接口的类，但不能代理声明为 final 类型的类和方法。

## 基础数据类型

## 对象引用

## 异常

## 注解

## SPI

## 版本特性

## 参考文章

- [Java源码剖析34讲](https://www.kancloud.cn/alex_wsc/java_source/1849598)

