---
title: Java
category: 基础模块
---

## 常用集合
### HashMap
实现：数组加链表，数组中的每一项是一个链表，通过计算存入对象的 HashCode，来计算对象在数组中要存入的位置，用链表来解决散列冲突，链表中的节点存储的是键值对。
### ConcurrentHashMap
1.7：使用 Segment 进行分段加锁，降低并发锁定；
1.8：使用 CAS 自旋锁的乐观锁来提高性能，但是在并发度较高时性能会比较一般


## JUC
### 原子类
例如：AtomicBoolean、AtomicLong、AtomicInteger、LongAdder、LongAccumulator等。
AtomicLong：通过 unsafe 类实现，基于CAS。
LongAdder：基于Cell，分段锁思想，空间换时间，更适合高并发场景。
LongAccumulator：提供了比LongAdder更强大的功能，能够指定对数据的操作规则，例如可以把对数据的相加操作改成相乘操作。
### 锁类
ReentrantLock
ReentrantReadWriteLock
StampedLock：JDK 1.8 改进的读写锁，是使用一种 CLH 的乐观锁，能够有效防止写饥饿。所谓写饥饿就是在多线程读写时，读线程访问非常频繁，导致总是有读线程占用资源，写线程很难加上写锁。
LockSupport
### 异步执行类
Executors：用于创建线程池
ForkJoinPool：1.7提供，采用分治思想，将大任务分解成多个小任务处理，然后在合并处理结果。特点是使用工作窃取算法，可以有效平衡多任务时间长短不一的场景。
FutureTask
CompletableFuture：可以支持流式调用，可以方便的进行多 future 的组合使用，例如可以同时执行两个异步任务，然后对执行结果进行合并处理。还可以很方便地设置完成时间。
### 阻塞队列类
LinkedBlockingDeque：双端队列，也就是可以分别从队头和队尾操作入队、出队。
ArrayBlockingQueue：单端队列，只能从队尾入队，队头出队。 
### 多线程协作类
CountDownLatch：实现计数器功能，可以用来控制等待多个线程执行任务后进行汇总。
CyclicBarrier：可以让一组线程等待至某个状态之后，再全部同时执行，一般在测试时使用，可以让多线程更好的并发执行。
Semaphore：用来控制对共享资源的访问并发度。允许多个线程共享资源，适用于限制使用共享资源线程数量的场景，例如 100 个车辆要使用 20 个停车位，那么最多允许 20 个车占用停车位。
### 集合类
ConcurrentHashMap：线程安全的HashMap。
CopyOnWriteArrayList：通过写入数据时进行 copy 修改，然后更新引用的方式，来消除并行读写中的锁使用，比较适合读多写少，数据量比较小，但是并发非常高的场景。

## 反射

## 动态代理

### JDK动态代理

### CGLIB动态代理
JDK 动态代理只能代理实现了接口的类或者直接代理接口；CGLIB 可以代理未实现任何接口的类，但不能代理声明为 final 类型的类和方法。

## 基础数据类型

## 对象引用

## 异常

## 注解

## SPI

## 版本特性

